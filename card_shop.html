<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カードショップ - Card Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .shop-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .shop-title {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .points-display {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #d4af37 0%, #b8941f 100%);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        @media (max-width: 992px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .cards-section, .inventory-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .shop-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .shop-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            border-color: #667eea;
        }
        
        .card-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .card-rarity {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }
        
        .rarity-N { background: #e0e0e0; color: #333; }
        .rarity-R { background: #3498db; color: white; }
        .rarity-SR { background: #e67e22; color: white; }
        .rarity-UR { background: #e74c3c; color: white; }
        .rarity-Secret { background: linear-gradient(45deg, #f39c12, #f1c40f); color: white; }
        .rarity-SE { background: linear-gradient(45deg, #c0c0c0, #e8e8e8); color: #333; }
        .rarity-PSE { background: linear-gradient(45deg, #8b4789, #9b59b6); color: white; }
        .rarity-QCSE { background: linear-gradient(45deg, #ffd700, #ffed4e); color: #333; }
        
        .card-price {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2ecc71;
            margin-bottom: 5px;
        }
        
        .price-change {
            font-size: 0.9rem;
            margin-left: 5px;
        }
        
        .price-up { color: #e74c3c; }
        .price-down { color: #3498db; }
        .price-stable { color: #95a5a6; }
        
        .buy-button {
            width: 100%;
            margin-top: 10px;
        }
        
        .inventory-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .inventory-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .profit { color: #2ecc71; }
        .loss { color: #e74c3c; }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .back-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .market-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-left: 10px;
        }
        
        .status-supply { background: #ecf0f1; color: #7f8c8d; }
        .status-reprint { background: #3498db; color: white; }
        .status-meta { background: #9b59b6; color: white; }
        .status-tournament { background: #e74c3c; color: white; }
        .status-demand { background: #f39c12; color: white; }
        .status-decline { background: #95a5a6; color: white; }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.location.href='card_list.html'">
        <i class="bi bi-arrow-left"></i> カード管理に戻る
    </button>

    <div class="shop-container">
        <div class="header-section">
            <h1 class="shop-title">
                <i class="bi bi-shop"></i> カードショップ
            </h1>
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                <div class="points-display">
                    <i class="bi bi-coin" style="font-size: 1.5rem; margin-right: 10px;"></i>
                    <span id="current-points">0</span> ポイント
                </div>
                <div class="d-flex align-items-center gap-3">
                    <span class="badge bg-primary"><i class="bi bi-calendar3"></i> <span id="game-date">2024年1月1日(月)</span></span>
                    <span class="badge bg-info">次の価格更新まで: <span id="next-update">10</span>秒</span>
                </div>
            </div>
            <div class="mt-2 d-flex justify-content-between align-items-center flex-wrap gap-2">
                <div class="d-flex align-items-center gap-2">
                    <label class="small">情報源:</label>
                    <select class="form-select form-select-sm" id="news-source" style="width: auto;">
                        <option value="none">なし</option>
                        <option value="trecaNews">トレカ日報</option>
                        <option value="trecaSpeed">トレカ速報</option>
                        <option value="marketWatch">市場ウォッチ</option>
                        <option value="paidNote">有料note (100pt/日)</option>
                    </select>
                </div>
                <div id="market-state" class="badge bg-danger" style="display: none;">
                    <i class="bi bi-graph-up-arrow"></i> <span id="market-state-text">バブル発生中</span>
                </div>
            </div>
            <div class="mt-3 text-center">
                <div class="alert alert-warning d-inline-block" style="background: linear-gradient(135deg, #fff3cd 0%, #ffe4a1 100%); border: 2px solid #ffc107;">
                    <i class="bi bi-lightbulb-fill text-warning me-2"></i>
                    <span id="market-prediction" class="fw-bold"></span>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="cards-section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2 class="section-title">
                        <i class="bi bi-cart3"></i> 販売中のカード
                    </h2>
                    <div>
                        <select class="form-select form-select-sm" id="sort-select">
                            <option value="name">名前順</option>
                            <option value="price-asc">価格: 安い順</option>
                            <option value="price-desc">価格: 高い順</option>
                            <option value="rarity">レアリティ順</option>
                        </select>
                    </div>
                </div>
                <div class="card-grid" id="cards-container">
                    <!-- Cards will be dynamically loaded here -->
                </div>
            </div>

            <div class="inventory-section">
                <h2 class="section-title">
                    <i class="bi bi-box-seam"></i> インベントリ
                </h2>
                <div class="mb-3">
                    <div class="alert alert-info mb-2">
                        <small>保有カード: <span id="inventory-count">0</span>枚</small><br>
                        <small>総投資額: <span id="total-invested">0</span>pt</small><br>
                        <small>現在価値: <span id="current-value">0</span>pt</small><br>
                        <small>損益: <span id="profit-loss" class="fw-bold">0</span>pt</small>
                    </div>
                </div>
                <div id="inventory-container">
                    <!-- Inventory items will be dynamically loaded here -->
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay active" id="loading">
        <div class="spinner"></div>
    </div>

    <!-- Login Modal -->
    <div class="modal fade" id="auth-modal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
        <div class="modal-dialog"><div class="modal-content">
            <div class="modal-header"><h5 class="modal-title">ログインまたは新規登録</h5></div>
            <div class="modal-body">
                <div id="auth-error" class="alert alert-danger" style="display: none;"></div>
                <form id="auth-form">
                    <div class="mb-3"><label for="email" class="form-label">メールアドレス</label><input type="email" class="form-control" id="email" required></div>
                    <div class="mb-3"><label for="password" class="form-label">パスワード</label><input type="password" class="form-control" id="password" required></div>
                    <div class="d-grid gap-2">
                        <button type="button" id="login-btn" class="btn btn-primary">ログイン</button>
                        <button type="button" id="signup-btn" class="btn btn-secondary">新規登録</button>
                    </div>
                </form>
            </div>
        </div></div>
    </div>

    <!-- Price History Modal -->
    <div class="modal fade" id="priceHistoryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">価格推移グラフ</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6 id="chartCardName" class="mb-3 text-center fw-bold"></h6>
                    <div style="height: 350px; position: relative;">
                        <canvas id="priceChart"></canvas>
                    </div>
                    <div class="mt-3">
                        <div class="row">
                            <div class="col-6">
                                <small class="text-muted">現在価格:</small>
                                <h5 id="chartCurrentPrice" class="text-primary"></h5>
                            </div>
                            <div class="col-6">
                                <small class="text-muted">基本価格:</small>
                                <h5 id="chartBasePrice" class="text-secondary"></h5>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-6">
                                <small class="text-muted">最高価格:</small>
                                <h5 id="chartMaxPrice" class="text-success"></h5>
                            </div>
                            <div class="col-6">
                                <small class="text-muted">最低価格:</small>
                                <h5 id="chartMinPrice" class="text-danger"></h5>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { 
            getAuth, 
            onAuthStateChanged,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            setPersistence,
            browserLocalPersistence
        } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';
        import { 
            getFirestore, 
            doc, 
            getDoc,
            setDoc,
            updateDoc,
            collection,
            query,
            where,
            getDocs,
            addDoc,
            deleteDoc,
            serverTimestamp
        } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';

        // Firebase configuration (same as card_list.html)
        const firebaseConfig = {
            apiKey: "AIzaSyAOYKalLUb2hbghrjQUS8AWzxpLExBT7aU",
            authDomain: "ygoh-9bcf6.firebaseapp.com",
            projectId: "ygoh-9bcf6",
            storageBucket: "ygoh-9bcf6.firebasestorage.app",
            messagingSenderId: "515041224138",
            appId: "1:515041224138:web:8de47b38ed9cc1bb8afd37",
            measurementId: "G-ZGSRE8MHZ2"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Set persistence to LOCAL (keeps user logged in)
        setPersistence(auth, browserLocalPersistence).catch((error) => {
            console.error('Error setting persistence:', error);
        });

        let currentUser = null;
        let userPoints = 0;
        let isSpinning = false;
        let authChecked = false;
        let inventory = [];
        let cardPrices = {};
        let updateInterval = null;
        
        // Game date system (starts from January 1st, Monday)
        let gameDate = new Date(2024, 0, 1); // January 1, 2024 (Monday)
        let selectedNewsSource = 'none';
        let isSubscribedToPaidNote = false;
        let globalMarketState = null; // null, 'bubble', 'bubble_continuing'
        let lastRegulationDate = null;

        // Virtual card database
        const CARDS_DATABASE = [
            { id: 'card-001', name: '黒魔女ディアベルスター', rarity: 'QCSE', basePrice: 9000 },
            { id: 'card-002', name: 'ユベル', rarity: 'SR', basePrice: 300 },
            { id: 'card-003', name: '反逆の罪宝－スネークアイ', rarity: 'SE', basePrice: 1500 },
            { id: 'card-004', name: '青眼の白龍', rarity: 'SE', basePrice: 30000 },
            { id: 'card-005', name: 'ブラック・マジシャン', rarity: 'SE', basePrice: 2500 },
            { id: 'card-006', name: '真紅眼の黒竜', rarity: 'UR', basePrice: 1500 },
            { id: 'card-007', name: '封印されしエクゾディア', rarity: 'UR', basePrice: 800 },
            { id: 'card-008', name: '黄金卿エルドリッチ', rarity: 'UR', basePrice: 600 },
            { id: 'card-009', name: 'カオス・ソルジャー－開闢の使者－', rarity: 'UR', basePrice: 800 },
            { id: 'card-010', name: '青眼の亜白龍', rarity: 'SE', basePrice: 400 },
            { id: 'card-011', name: 'I:Pマスカレーナ', rarity: 'PSE', basePrice: 25000 },
            { id: 'card-012', name: 'アクセスコード・トーカー', rarity: 'SE', basePrice: 800 },
            { id: 'card-013', name: '灰流うらら', rarity: 'SR', basePrice: 400 },
            { id: 'card-014', name: '増殖するG', rarity: 'SR', basePrice: 400 },
            { id: 'card-015', name: '神の宣告', rarity: 'UR', basePrice: 200 },
            { id: 'card-016', name: 'ブラック・マジシャン・ガール', rarity: 'UR', basePrice: 700 },
            { id: 'card-017', name: '無限泡影', rarity: 'UR', basePrice: 800 },
            { id: 'card-018', name: '月女神の鏃', rarity: 'UR', basePrice: 500 },
            { id: 'card-019', name: 'マルチャミー・フワロス', rarity: 'R', basePrice: 1300 }
        ];

        // Price fluctuation patterns
        const PRICE_PATTERNS = {
            SUPPLY: 'supply',      // 市場供給量の変化
            REPRINT: 'reprint',    // 再録
            META: 'meta',          // 環境の変化
            TOURNAMENT: 'tournament', // 大会での結果
            DEMAND: 'demand',      // 需要増加
            DECLINE: 'decline',    // 需要低下
            REGULATION: 'regulation' // 規制
        };
        
        // News sources with hidden accuracy rates
        const NEWS_SOURCES = {
            none: { name: 'なし', accuracy: 0.1, cost: 0 },
            trecaNews: { name: 'トレカ日報', accuracy: 0.35, cost: 0 }, // Hidden: 35%
            trecaSpeed: { name: 'トレカ速報', accuracy: 0.45, cost: 0 }, // Hidden: 45%
            marketWatch: { name: '市場ウォッチ', accuracy: 0.55, cost: 0 }, // Hidden: 55%
            paidNote: { name: '有料note (100pt/日)', accuracy: 0.85, cost: 100 } // Hidden: 85%
        };

        // Initialize
        let authModal = null;
        
        // Wait for DOM to be ready before setting up auth
        window.addEventListener('DOMContentLoaded', () => {
            const authModalElement = document.getElementById('auth-modal');
            
            if (authModalElement) {
                authModal = new bootstrap.Modal(authModalElement);
            }
            
            // Setup auth state listener
            onAuthStateChanged(auth, async (user) => {
                console.log('Auth state changed:', user ? 'User logged in' : 'No user');
                if (user) {
                    currentUser = user;
                    // Hide modal if it exists
                    if (authModal) {
                        authModal.hide();
                    }
                    await loadUserData();
                    await loadCardPrices();
                    await loadInventory();
                    displayCards();
                    displayInventory();
                    updateDateDisplay();
                    generateMarketPrediction();
                    startPriceUpdateTimer();
                    document.getElementById('loading').classList.remove('active');
                } else {
                    // User not logged in - show login modal
                    document.getElementById('loading').classList.remove('active');
                    if (authModal) {
                        authModal.show();
                    }
                }
            });
        });

        // Load user points
        async function loadUserData() {
            try {
                const gamificationRef = doc(db, 'userGamification', currentUser.uid);
                const gamificationSnap = await getDoc(gamificationRef);
                
                if (gamificationSnap.exists()) {
                    const data = gamificationSnap.data();
                    // card_list.html uses 'userPoints' field
                    userPoints = data.userPoints || data.points || 0;
                    document.getElementById('current-points').textContent = userPoints.toLocaleString();
                }
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        }

        // Save user points
        async function saveUserPoints() {
            try {
                const gamificationRef = doc(db, 'userGamification', currentUser.uid);
                // Use 'userPoints' field to match card_list.html
                await updateDoc(gamificationRef, { userPoints: userPoints });
                document.getElementById('current-points').textContent = userPoints.toLocaleString();
            } catch (error) {
                console.error('Error saving points:', error);
            }
        }

        // Load or initialize card prices
        async function loadCardPrices() {
            try {
                const pricesRef = doc(db, 'cardShopPrices', 'current');
                const pricesSnap = await getDoc(pricesRef);
                
                const now = Date.now();
                const tenSeconds = 10 * 1000;
                
                if (pricesSnap.exists()) {
                    const data = pricesSnap.data();
                    const lastUpdate = data.lastUpdate?.toMillis() || 0;
                    
                    // Load saved game state
                    if (data.gameDate) {
                        gameDate = new Date(data.gameDate);
                    }
                    if (data.globalMarketState !== undefined) {
                        globalMarketState = data.globalMarketState;
                    }
                    if (data.lastRegulationDate) {
                        lastRegulationDate = new Date(data.lastRegulationDate);
                    }
                    
                    // Update prices if 10 seconds have passed
                    if (now - lastUpdate >= tenSeconds) {
                        await updateCardPrices();
                    } else {
                        cardPrices = data.prices || {};
                        // Initialize missing prices only (for new cards)
                        CARDS_DATABASE.forEach(card => {
                            if (!cardPrices[card.id]) {
                                cardPrices[card.id] = {
                                    current: card.basePrice,
                                    previous: card.basePrice,
                                    pattern: PRICE_PATTERNS.SUPPLY,
                                    patternStart: now,
                                    history: []
                                };
                            } else {
                                // Ensure history array exists for existing prices
                                if (!cardPrices[card.id].history) {
                                    cardPrices[card.id].history = [];
                                }
                            }
                        });
                    }
                } else {
                    // Initialize all prices
                    CARDS_DATABASE.forEach(card => {
                        cardPrices[card.id] = {
                            current: card.basePrice,
                            previous: card.basePrice,
                            pattern: PRICE_PATTERNS.SUPPLY,
                            patternStart: now,
                            history: []
                        };
                    });
                    await savePrices();
                }
            } catch (error) {
                console.error('Error loading prices:', error);
            }
        }

        // Update card prices based on patterns
        async function updateCardPrices() {
            const now = Date.now();
            
            // Advance game date
            gameDate.setDate(gameDate.getDate() + 1);
            updateDateDisplay();
            
            // Check for paid note subscription
            if (isSubscribedToPaidNote) {
                userPoints = Math.max(0, userPoints - NEWS_SOURCES.paidNote.cost);
                await saveUserPoints();
            }
            
            // First, ensure we have the latest prices from Firebase
            if (Object.keys(cardPrices).length === 0) {
                try {
                    const pricesRef = doc(db, 'cardShopPrices', 'current');
                    const pricesSnap = await getDoc(pricesRef);
                    if (pricesSnap.exists()) {
                        const data = pricesSnap.data();
                        cardPrices = data.prices || {};
                        // Don't reset date here - it's already loaded in loadCardPrices
                    }
                } catch (error) {
                    console.error('Error loading existing prices:', error);
                }
            }
            
            // Check for global market events
            handleGlobalMarketEvents();
            
            // Check for regulation (once per month on the 1st)
            const isRegulationDay = gameDate.getDate() === 1 && 
                (!lastRegulationDate || lastRegulationDate.getMonth() !== gameDate.getMonth());
            
            // Check if weekend for tournament
            const dayOfWeek = gameDate.getDay();
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
            let tournamentCardSelected = false;
            
            CARDS_DATABASE.forEach(card => {
                const price = cardPrices[card.id] || {
                    current: card.basePrice,
                    previous: card.basePrice,
                    pattern: PRICE_PATTERNS.SUPPLY,
                    patternStart: now,
                    continuationCount: 0,
                    history: []
                };
                
                // Save previous price
                price.previous = price.current;
                price.history.push({
                    price: price.current,
                    timestamp: now,
                    date: gameDate.toISOString()
                });
                
                // Keep only last 20 history entries
                if (price.history.length > 20) {
                    price.history.shift();
                }
                
                // Determine next pattern
                let nextPattern = price.pattern;
                const rand = Math.random();
                
                // Special events override normal patterns
                if (isRegulationDay) {
                    // Regulation affects random cards
                    if (Math.random() < 0.2) { // 20% chance per card
                        nextPattern = PRICE_PATTERNS.REGULATION;
                    }
                } else if (isWeekend && !tournamentCardSelected && Math.random() < 0.1) {
                    // Tournament on weekend (one card per day)
                    nextPattern = PRICE_PATTERNS.TOURNAMENT;
                    tournamentCardSelected = true;
                } else {
                    // Normal pattern transitions
                    switch (price.pattern) {
                        case PRICE_PATTERNS.SUPPLY:
                            // 60% continue, else change
                            if (rand > 0.6) {
                                const patterns = [PRICE_PATTERNS.META, PRICE_PATTERNS.DEMAND, PRICE_PATTERNS.REPRINT];
                                nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                            }
                            break;
                        
                        case PRICE_PATTERNS.REPRINT:
                            // PSE and QCSE cannot be reprinted
                            if (card.rarity === 'PSE' || card.rarity === 'QCSE') {
                                nextPattern = PRICE_PATTERNS.SUPPLY;
                            } else {
                                // 80% continue reprint
                                if (rand > 0.8) {
                                    nextPattern = PRICE_PATTERNS.SUPPLY;
                                }
                            }
                            break;
                        
                        case PRICE_PATTERNS.META:
                            // Random change
                            if (rand < 0.3) {
                                const patterns = [PRICE_PATTERNS.SUPPLY, PRICE_PATTERNS.DEMAND, PRICE_PATTERNS.DECLINE];
                                nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                            }
                            break;
                        
                        case PRICE_PATTERNS.TOURNAMENT:
                            // 30% continue, else decline
                            nextPattern = rand < 0.3 ? PRICE_PATTERNS.TOURNAMENT : PRICE_PATTERNS.DECLINE;
                            break;
                        
                        case PRICE_PATTERNS.DEMAND:
                            // 40% continue, else decline
                            nextPattern = rand < 0.4 ? PRICE_PATTERNS.DEMAND : PRICE_PATTERNS.DECLINE;
                            break;
                        
                        case PRICE_PATTERNS.DECLINE:
                            // 60% continue
                            if (rand > 0.6) {
                                const patterns = [PRICE_PATTERNS.SUPPLY, PRICE_PATTERNS.META];
                                nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                            }
                            break;
                        
                        case PRICE_PATTERNS.REGULATION:
                            // Return to supply after regulation
                            nextPattern = PRICE_PATTERNS.SUPPLY;
                            break;
                        
                        default:
                            nextPattern = PRICE_PATTERNS.SUPPLY;
                            break;
                    }
                }
                
                // Change pattern if different
                if (nextPattern !== price.pattern) {
                    price.pattern = nextPattern;
                    price.patternStart = now;
                    price.continuationCount = 0;
                } else {
                    price.continuationCount++;
                }
                
                // Check if card is immune to price decreases
                const isImmune = (card.rarity === 'PSE' || card.rarity === 'QCSE' || 
                    (card.name === '青眼の白龍' && card.rarity === 'SE'));
                
                // Apply price changes based on pattern
                let multiplier = 1;
                
                switch (price.pattern) {
                    case PRICE_PATTERNS.SUPPLY:
                        // Gradual decrease (immune cards unaffected)
                        multiplier = isImmune ? 1 : (0.94 + Math.random() * 0.03); // 0.94-0.97
                        break;
                    
                    case PRICE_PATTERNS.REPRINT:
                        // Sharp decrease (PSE/QCSE/青眼SE immune)
                        multiplier = isImmune ? 1 : (0.5 + Math.random() * 0.2); // 0.5-0.7
                        break;
                    
                    case PRICE_PATTERNS.META:
                        // Up or down randomly
                        const isUp = Math.random() < 0.5;
                        if (isUp) {
                            multiplier = 1.05 + Math.random() * 0.1; // 1.05-1.15 up
                        } else {
                            // Immune cards don't go down
                            multiplier = isImmune ? 1 : (0.85 + Math.random() * 0.1); // 0.85-0.95 down
                        }
                        break;
                    
                    case PRICE_PATTERNS.TOURNAMENT:
                        // Sharp increase
                        multiplier = 1.3 + Math.random() * 0.3; // 1.3-1.6
                        break;
                    
                    case PRICE_PATTERNS.DEMAND:
                        // Gradual increase then stable
                        if (price.continuationCount < 3) {
                            multiplier = 1.08 + Math.random() * 0.07; // 1.08-1.15
                        } else {
                            multiplier = 0.98 + Math.random() * 0.04; // 0.98-1.02 (stable)
                        }
                        break;
                    
                    case PRICE_PATTERNS.DECLINE:
                        // Gradual decrease (immune cards unaffected)
                        multiplier = isImmune ? 1 : (0.92 + Math.random() * 0.04); // 0.92-0.96
                        break;
                    
                    case PRICE_PATTERNS.REGULATION:
                        // Sharp change up or down (regulation affects all cards)
                        multiplier = Math.random() < 0.5 ? 
                            (0.4 + Math.random() * 0.2) :  // 0.4-0.6 (banned/limited)
                            (1.5 + Math.random() * 0.5);   // 1.5-2.0 (unbanned)
                        break;
                }
                
                // Apply global market effects
                if (globalMarketState === 'bubble' || globalMarketState === 'bubble_continuing') {
                    multiplier *= 1.05; // Additional 5% for bubble
                } else if (globalMarketState === 'crash') {
                    multiplier *= 0.4; // 60% decrease for crash
                }
                
                // Apply multiplier with minimum price (10% of base) and no maximum cap
                price.current = Math.max(
                    Math.floor(card.basePrice * 0.1),
                    Math.floor(price.current * multiplier)
                );
                
                cardPrices[card.id] = price;
            });
            
            // Update regulation date if needed
            if (isRegulationDay) {
                lastRegulationDate = new Date(gameDate);
            }
            
            await savePrices();
            displayCards();
            updateInventoryDisplay();
            generateMarketPrediction();
        }
        
        // Handle global market events (bubble/crash)
        function handleGlobalMarketEvents() {
            const rand = Math.random();
            
            if (globalMarketState === null) {
                // Check for bubble start (1% chance)
                if (rand < 0.01) {
                    globalMarketState = 'bubble';
                    // All prices increase by 40% + 350
                    Object.keys(cardPrices).forEach(cardId => {
                        cardPrices[cardId].current = Math.floor(cardPrices[cardId].current * 1.4 + 350);
                    });
                    showMarketAlert('バブル発生', 'カード市場にバブルが発生！全カードの価格が40%+350pt上昇！');
                }
            } else if (globalMarketState === 'bubble') {
                // Check for bubble burst (30% chance) or continue
                if (rand < 0.3) {
                    globalMarketState = 'crash';
                    showMarketAlert('バブル崩壊', '市場が崩壊！全カードの価格が60%暴落！');
                } else {
                    globalMarketState = 'bubble_continuing';
                    showMarketAlert('バブル継続', 'バブルが継続中！価格がさらに5%上昇！');
                }
            } else if (globalMarketState === 'bubble_continuing') {
                // Check for bubble burst (30% chance)
                if (rand < 0.3) {
                    globalMarketState = 'crash';
                    showMarketAlert('バブル崩壊', '市場が崩壊！全カードの価格が60%暴落！');
                }
            } else if (globalMarketState === 'crash') {
                // Recovery from crash
                globalMarketState = null;
            }
            
            // Update market state display
            const marketStateEl = document.getElementById('market-state');
            if (globalMarketState && globalMarketState !== 'crash') {
                marketStateEl.style.display = 'inline-block';
                document.getElementById('market-state-text').textContent = 
                    globalMarketState.includes('bubble') ? 'バブル発生中' : '';
            } else {
                marketStateEl.style.display = 'none';
            }
        }
        
        // Show market alert
        function showMarketAlert(title, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-danger position-fixed top-50 start-50 translate-middle';
            alertDiv.style.zIndex = '9999';
            alertDiv.style.minWidth = '300px';
            alertDiv.innerHTML = `
                <h5 class="alert-heading">${title}</h5>
                <p>${message}</p>
            `;
            document.body.appendChild(alertDiv);
            setTimeout(() => alertDiv.remove(), 5000);
        }
        
        // Update date display
        function updateDateDisplay() {
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            const dateStr = `${gameDate.getFullYear()}年${gameDate.getMonth() + 1}月${gameDate.getDate()}日(${days[gameDate.getDay()]})`;
            const dateEl = document.getElementById('game-date');
            if (dateEl) dateEl.textContent = dateStr;
        }

        // Generate market prediction comments
        function generateMarketPrediction() {
            // Select a random card to predict about
            const targetCard = CARDS_DATABASE[Math.floor(Math.random() * CARDS_DATABASE.length)];
            const targetPrice = cardPrices[targetCard.id];
            
            if (!targetPrice) return;
            
            // Use selected news source accuracy
            const accuracy = NEWS_SOURCES[selectedNewsSource]?.accuracy || 0.1;
            const isAccurate = Math.random() < accuracy;
            
            // Determine actual next pattern for the card
            const actualPattern = targetPrice.pattern;
            let predictedDirection = null;
            let actualDirection = null;
            
            // Determine actual price direction based on pattern
            switch (actualPattern) {
                case PRICE_PATTERNS.TOURNAMENT:
                case PRICE_PATTERNS.DEMAND:
                    actualDirection = 'up';
                    break;
                case PRICE_PATTERNS.DECLINE:
                case PRICE_PATTERNS.REPRINT:
                    actualDirection = 'down';
                    break;
                case PRICE_PATTERNS.SUPPLY:
                case PRICE_PATTERNS.META:
                    actualDirection = Math.random() < 0.5 ? 'stable' : (Math.random() < 0.5 ? 'up' : 'down');
                    break;
            }
            
            // Decide prediction (40% accurate)
            if (isAccurate) {
                predictedDirection = actualDirection;
            } else {
                // Wrong prediction
                const directions = ['up', 'down', 'stable'];
                const wrongDirections = directions.filter(d => d !== actualDirection);
                predictedDirection = wrongDirections[Math.floor(Math.random() * wrongDirections.length)];
            }
            
            // Generate prediction message based on direction and pattern
            let prediction = '';
            
            if (predictedDirection === 'up') {
                const reasons = [
                    {
                        text: `🔥「${targetCard.name}」が急騰の予感！大会での採用率上昇により、次の更新で20-30%上昇か！？`,
                        detail: "トーナメントシーンでの活躍が目立ち始めた"
                    },
                    {
                        text: `💎「${targetCard.name}」に注目！新カードとのシナジーが発見され、需要急増で価格上昇必至！？`,
                        detail: "コンボデッキのキーパーツとして再評価"
                    },
                    {
                        text: `📈「${targetCard.name}」買い時到来！環境トップデッキの必須カードに。早めの確保を推奨！`,
                        detail: "メタゲームの中心に躍り出る可能性大"
                    },
                    {
                        text: `🚀「${targetCard.name}」爆上げ警報！海外での人気急騰により、国内価格も追従する見込み！`,
                        detail: "グローバル市場での需要が影響"
                    },
                    {
                        text: `⚡「${targetCard.name}」仕込み時！制限改訂の緩和候補として、事前買いが殺到か！？`,
                        detail: "規制緩和の噂が価格に影響"
                    }
                ];
                const selected = reasons[Math.floor(Math.random() * reasons.length)];
                prediction = `${selected.text} 理由：${selected.detail}`;
                
            } else if (predictedDirection === 'down') {
                const reasons = [
                    {
                        text: `📉「${targetCard.name}」暴落注意！再録決定の情報により、現在価格から50%下落の可能性！`,
                        detail: "新パックでの再録がほぼ確定"
                    },
                    {
                        text: `💔「${targetCard.name}」売り時！環境から外れ、需要激減で価格下落は避けられない！`,
                        detail: "メタ環境の変化で採用率が激減"
                    },
                    {
                        text: `⚠️「${targetCard.name}」要注意！上位互換の新カード登場で、価値が大幅に下がる見込み！`,
                        detail: "より強力な代替カードの登場"
                    },
                    {
                        text: `🌊「${targetCard.name}」下落トレンド！供給過多により、しばらく価格回復は期待できない！`,
                        detail: "市場に在庫が溢れている状態"
                    },
                    {
                        text: `😱「${targetCard.name}」規制リスク！次回制限で規制強化の可能性、今のうちに売却推奨！`,
                        detail: "パワーレベルが問題視されている"
                    }
                ];
                const selected = reasons[Math.floor(Math.random() * reasons.length)];
                prediction = `${selected.text} 理由：${selected.detail}`;
                
            } else {
                const reasons = [
                    {
                        text: `⏸️「${targetCard.name}」は様子見！価格は横ばい予想、急な変動は期待薄！`,
                        detail: "市場が安定期に入り大きな動きなし"
                    },
                    {
                        text: `🎯「${targetCard.name}」現状維持！需給バランスが取れており、価格変動は限定的！`,
                        detail: "適正価格に落ち着いている"
                    },
                    {
                        text: `💭「${targetCard.name}」判断保留！情報不足により、投資判断は次の更新まで待つべき！`,
                        detail: "決定的な材料が不足している"
                    },
                    {
                        text: `🔄「${targetCard.name}」小幅変動！上下10%程度の範囲で推移、大きな利益は期待できない！`,
                        detail: "ボラティリティが低い状態が継続"
                    }
                ];
                const selected = reasons[Math.floor(Math.random() * reasons.length)];
                prediction = `${selected.text} 理由：${selected.detail}`;
            }
            
            // Update the prediction display
            const predictionElement = document.getElementById('market-prediction');
            if (predictionElement) {
                predictionElement.innerHTML = prediction;
            }
        }

        // Save prices to Firestore
        async function savePrices() {
            try {
                await setDoc(doc(db, 'cardShopPrices', 'current'), {
                    prices: cardPrices,
                    lastUpdate: serverTimestamp(),
                    gameDate: gameDate.toISOString(),
                    globalMarketState: globalMarketState,
                    lastRegulationDate: lastRegulationDate ? lastRegulationDate.toISOString() : null
                });
            } catch (error) {
                console.error('Error saving prices:', error);
            }
        }

        // Load user inventory
        async function loadInventory() {
            try {
                const inventoryRef = collection(db, 'userInventory', currentUser.uid, 'cards');
                const inventorySnap = await getDocs(inventoryRef);
                
                inventory = [];
                inventorySnap.forEach(doc => {
                    inventory.push({
                        docId: doc.id,
                        ...doc.data()
                    });
                });
            } catch (error) {
                console.error('Error loading inventory:', error);
            }
        }

        // Buy card with quantity selection
        window.buyCard = async (cardId, quantity = null) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            if (!card || !price) return;
            
            // If quantity not specified, show quantity selector
            if (quantity === null) {
                const quantities = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                const maxQty = Math.floor(userPoints / price.current);
                
                if (maxQty === 0) {
                    alert('ポイントが不足しています！');
                    return;
                }
                
                // Create quantity buttons
                const quantityHTML = quantities
                    .filter(q => q <= maxQty)
                    .map(q => `<button class="btn btn-sm btn-outline-primary mx-1" onclick="buyCard('${cardId}', ${q})">${q}枚</button>`)
                    .join('');
                
                const modal = document.createElement('div');
                modal.className = 'modal fade show';
                modal.style.display = 'block';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${card.name} を購入</h5>
                                <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                            </div>
                            <div class="modal-body">
                                <p>価格: ${price.current.toLocaleString()} pt/枚</p>
                                <p>最大購入可能: ${maxQty}枚</p>
                                <div class="d-flex flex-wrap justify-content-center mt-3">
                                    ${quantityHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                return;
            }
            
            // Buy specified quantity
            const totalCost = price.current * quantity;
            if (userPoints < totalCost) {
                alert('ポイントが不足しています！');
                return;
            }
            
            userPoints -= totalCost;
            await saveUserPoints();
            
            // Add multiple cards to inventory
            const inventoryRef = collection(db, 'userInventory', currentUser.uid, 'cards');
            const promises = [];
            for (let i = 0; i < quantity; i++) {
                promises.push(addDoc(inventoryRef, {
                    cardId: cardId,
                    purchasePrice: price.current,
                    purchaseTime: serverTimestamp()
                }));
            }
            await Promise.all(promises);
            
            await loadInventory();
            displayInventory();
            
            // Remove modal if exists
            const modal = document.querySelector('.modal.show');
            if (modal) modal.remove();
            
            // Show success message briefly
            const toast = document.createElement('div');
            toast.className = 'alert alert-success position-fixed top-50 start-50 translate-middle';
            toast.style.zIndex = '9999';
            toast.innerHTML = `<strong>${card.name}</strong> を ${quantity}枚 購入しました！`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        };

        // Sell card with quantity selection for stacked cards
        window.sellCard = async (cardId, purchasePrice = null) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            if (!card || !price) return;
            
            // Get all cards with same ID and purchase price
            let itemsToSell = inventory.filter(item => item.cardId === cardId);
            
            if (purchasePrice !== null) {
                itemsToSell = itemsToSell.filter(item => item.purchasePrice === purchasePrice);
            }
            
            if (itemsToSell.length === 0) return;
            
            const profit = price.current - (purchasePrice || itemsToSell[0].purchasePrice);
            const profitText = profit >= 0 ? `+${profit}` : profit;
            const profitClass = profit >= 0 ? 'text-success' : 'text-danger';
            
            // If multiple items with same price, show quantity selector
            if (itemsToSell.length > 1) {
                const modal = document.createElement('div');
                modal.className = 'modal fade show';
                modal.style.display = 'block';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                
                const quantityButtons = [];
                for (let i = 1; i <= Math.min(itemsToSell.length, 9); i++) {
                    const totalProfit = profit * i;
                    const totalRevenue = price.current * i;
                    quantityButtons.push(`
                        <button class="btn btn-sm btn-outline-danger mx-1 mb-2" 
                                onclick="sellMultiple('${cardId}', ${purchasePrice || itemsToSell[0].purchasePrice}, ${i})">
                            ${i}枚 (${totalRevenue.toLocaleString()}pt)
                        </button>
                    `);
                }
                
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${card.name} を売却</h5>
                                <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                            </div>
                            <div class="modal-body">
                                <p>現在価格: ${price.current.toLocaleString()} pt/枚</p>
                                <p>購入価格: ${(purchasePrice || itemsToSell[0].purchasePrice).toLocaleString()} pt/枚</p>
                                <p class="${profitClass}">損益: ${profitText} pt/枚</p>
                                <p>所持数: ${itemsToSell.length}枚</p>
                                <div class="d-flex flex-wrap justify-content-center mt-3">
                                    ${quantityButtons.join('')}
                                </div>
                                <button class="btn btn-danger w-100 mt-2" 
                                        onclick="sellMultiple('${cardId}', ${purchasePrice || itemsToSell[0].purchasePrice}, ${itemsToSell.length})">
                                    全て売却 (${itemsToSell.length}枚)
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                // Single item, sell directly
                await sellMultiple(cardId, purchasePrice || itemsToSell[0].purchasePrice, 1);
            }
        };
        
        // Sell multiple cards
        window.sellMultiple = async (cardId, purchasePrice, quantity) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            const itemsToSell = inventory
                .filter(item => item.cardId === cardId && item.purchasePrice === purchasePrice)
                .slice(0, quantity);
            
            if (itemsToSell.length === 0) return;
            
            const totalRevenue = price.current * itemsToSell.length;
            userPoints += totalRevenue;
            await saveUserPoints();
            
            // Delete items from inventory
            const deletePromises = itemsToSell.map(item => 
                deleteDoc(doc(db, 'userInventory', currentUser.uid, 'cards', item.docId))
            );
            await Promise.all(deletePromises);
            
            await loadInventory();
            displayInventory();
            
            // Remove modal
            const modal = document.querySelector('.modal.show');
            if (modal) modal.remove();
            
            // Show success message
            const profit = (price.current - purchasePrice) * itemsToSell.length;
            const toast = document.createElement('div');
            toast.className = `alert alert-${profit >= 0 ? 'success' : 'warning'} position-fixed top-50 start-50 translate-middle`;
            toast.style.zIndex = '9999';
            toast.innerHTML = `
                <strong>${card.name}</strong> を ${itemsToSell.length}枚 売却しました！<br>
                獲得: ${totalRevenue.toLocaleString()} pt<br>
                損益: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()} pt
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        };

        // Display cards in shop
        function displayCards() {
            const container = document.getElementById('cards-container');
            const sortSelect = document.getElementById('sort-select');
            
            let sortedCards = [...CARDS_DATABASE];
            
            // Apply sorting
            switch (sortSelect.value) {
                case 'price-asc':
                    sortedCards.sort((a, b) => cardPrices[a.id].current - cardPrices[b.id].current);
                    break;
                case 'price-desc':
                    sortedCards.sort((a, b) => cardPrices[b.id].current - cardPrices[a.id].current);
                    break;
                case 'rarity':
                    const rarityOrder = { 'N': 0, 'R': 1, 'SR': 2, 'UR': 3, 'Secret': 4 };
                    sortedCards.sort((a, b) => rarityOrder[b.rarity] - rarityOrder[a.rarity]);
                    break;
                default:
                    sortedCards.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            container.innerHTML = sortedCards.map(card => {
                const price = cardPrices[card.id];
                const priceChange = price.current - price.previous;
                const priceChangeClass = priceChange > 0 ? 'price-up' : priceChange < 0 ? 'price-down' : 'price-stable';
                const priceChangeIcon = priceChange > 0 ? '↑' : priceChange < 0 ? '↓' : '→';
                const priceChangeText = priceChange !== 0 ? Math.abs(priceChange) : '';
                
                const patternBadge = getPatternBadge(price.pattern);
                
                return `
                    <div class="shop-card">
                        <div class="card-name">${card.name}</div>
                        <span class="card-rarity rarity-${card.rarity}">${card.rarity}</span>
                        ${patternBadge}
                        <div class="card-price">
                            ${price.current.toLocaleString()} pt
                            <span class="price-change ${priceChangeClass}">
                                ${priceChangeIcon} ${priceChangeText}
                            </span>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary buy-button flex-grow-1" onclick="buyCard('${card.id}')">
                                <i class="bi bi-cart-plus"></i> 購入
                            </button>
                            <button class="btn btn-outline-secondary" onclick="showPriceHistory('${card.id}')" title="価格推移">
                                <i class="bi bi-graph-up"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Display inventory with stacking
        function displayInventory() {
            const container = document.getElementById('inventory-container');
            
            if (inventory.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">カードを所有していません</p>';
                updateInventoryStats();
                return;
            }
            
            // Group inventory by cardId and purchasePrice
            const groupedInventory = {};
            inventory.forEach(item => {
                const key = `${item.cardId}_${item.purchasePrice}`;
                if (!groupedInventory[key]) {
                    groupedInventory[key] = {
                        cardId: item.cardId,
                        purchasePrice: item.purchasePrice,
                        items: [],
                        earliestDate: item.purchaseTime
                    };
                }
                groupedInventory[key].items.push(item);
                if (item.purchaseTime < groupedInventory[key].earliestDate) {
                    groupedInventory[key].earliestDate = item.purchaseTime;
                }
            });
            
            // Add "Sell all profitable" button if there are profitable cards
            const profitableGroups = Object.values(groupedInventory).filter(group => {
                const price = cardPrices[group.cardId];
                return price && price.current > group.purchasePrice;
            });
            
            let headerHTML = '';
            if (profitableGroups.length > 0) {
                const totalProfit = profitableGroups.reduce((sum, group) => {
                    const price = cardPrices[group.cardId];
                    return sum + ((price.current - group.purchasePrice) * group.items.length);
                }, 0);
                
                headerHTML = `
                    <button class="btn btn-success btn-sm w-100 mb-3" onclick="sellAllProfitable()">
                        <i class="bi bi-graph-up"></i> 利益カード全売却 (+${totalProfit.toLocaleString()}pt)
                    </button>
                `;
            }
            
            // Display grouped inventory
            const inventoryHTML = Object.values(groupedInventory).map(group => {
                const card = CARDS_DATABASE.find(c => c.id === group.cardId);
                const price = cardPrices[group.cardId];
                
                if (!card || !price) return '';
                
                const profit = price.current - group.purchasePrice;
                const profitClass = profit >= 0 ? 'profit' : 'loss';
                const profitText = profit >= 0 ? `+${profit}` : profit;
                const totalProfit = profit * group.items.length;
                
                const purchaseDate = group.earliestDate?.toDate ? 
                    new Date(group.earliestDate.toDate()).toLocaleDateString('ja-JP') : 
                    '不明';
                
                const countBadge = group.items.length > 1 ? 
                    `<span class="badge bg-primary ms-2">${group.items.length}枚</span>` : '';
                
                return `
                    <div class="inventory-item">
                        <div class="inventory-item-header">
                            <strong>${card.name}${countBadge}</strong>
                            <span class="card-rarity rarity-${card.rarity}">${card.rarity}</span>
                        </div>
                        <div class="small text-muted">初回購入: ${purchaseDate}</div>
                        <div class="small">購入価格: ${group.purchasePrice.toLocaleString()}pt/枚</div>
                        <div class="small">現在価格: ${price.current.toLocaleString()}pt/枚</div>
                        <div class="small ${profitClass} fw-bold">
                            損益: ${profitText}pt/枚
                            ${group.items.length > 1 ? `(計: ${totalProfit >= 0 ? '+' : ''}${totalProfit.toLocaleString()}pt)` : ''}
                        </div>
                        <button class="btn btn-danger btn-sm w-100 mt-2" onclick="sellCard('${group.cardId}', ${group.purchasePrice})">
                            <i class="bi bi-cash"></i> 売却
                        </button>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = headerHTML + inventoryHTML;
            updateInventoryStats();
        }
        
        // Sell all profitable cards
        window.sellAllProfitable = async () => {
            const profitableItems = inventory.filter(item => {
                const price = cardPrices[item.cardId];
                return price && price.current > item.purchasePrice;
            });
            
            if (profitableItems.length === 0) {
                alert('利益が出ているカードがありません。');
                return;
            }
            
            const totalRevenue = profitableItems.reduce((sum, item) => {
                const price = cardPrices[item.cardId];
                return sum + price.current;
            }, 0);
            
            const totalProfit = profitableItems.reduce((sum, item) => {
                const price = cardPrices[item.cardId];
                return sum + (price.current - item.purchasePrice);
            }, 0);
            
            if (confirm(`利益が出ているカード ${profitableItems.length}枚 を全て売却しますか？\n\n獲得予定: ${totalRevenue.toLocaleString()}pt\n利益予定: +${totalProfit.toLocaleString()}pt`)) {
                userPoints += totalRevenue;
                await saveUserPoints();
                
                // Delete all profitable items
                const deletePromises = profitableItems.map(item => 
                    deleteDoc(doc(db, 'userInventory', currentUser.uid, 'cards', item.docId))
                );
                await Promise.all(deletePromises);
                
                await loadInventory();
                displayInventory();
                
                // Show success message
                const toast = document.createElement('div');
                toast.className = 'alert alert-success position-fixed top-50 start-50 translate-middle';
                toast.style.zIndex = '9999';
                toast.innerHTML = `
                    <strong>利益カード ${profitableItems.length}枚 を売却しました！</strong><br>
                    獲得: ${totalRevenue.toLocaleString()} pt<br>
                    利益: +${totalProfit.toLocaleString()} pt
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }
        };

        // Update inventory statistics
        function updateInventoryStats() {
            let totalInvested = 0;
            let currentValue = 0;
            
            inventory.forEach(item => {
                totalInvested += item.purchasePrice;
                const price = cardPrices[item.cardId];
                if (price) {
                    currentValue += price.current;
                }
            });
            
            const profitLoss = currentValue - totalInvested;
            const profitLossClass = profitLoss >= 0 ? 'profit' : 'loss';
            
            document.getElementById('inventory-count').textContent = inventory.length;
            document.getElementById('total-invested').textContent = totalInvested.toLocaleString();
            document.getElementById('current-value').textContent = currentValue.toLocaleString();
            
            const profitLossElement = document.getElementById('profit-loss');
            profitLossElement.textContent = (profitLoss >= 0 ? '+' : '') + profitLoss.toLocaleString();
            profitLossElement.className = `fw-bold ${profitLossClass}`;
        }

        // Update inventory display only
        function updateInventoryDisplay() {
            const container = document.getElementById('inventory-container');
            if (inventory.length > 0) {
                displayInventory();
            }
        }

        // Get pattern badge HTML
        function getPatternBadge(pattern) {
            const badges = {
                [PRICE_PATTERNS.SUPPLY]: '<span class="market-status status-supply">供給</span>',
                [PRICE_PATTERNS.REPRINT]: '<span class="market-status status-reprint">再録</span>',
                [PRICE_PATTERNS.META]: '<span class="market-status status-meta">環境</span>',
                [PRICE_PATTERNS.TOURNAMENT]: '<span class="market-status status-tournament">大会</span>',
                [PRICE_PATTERNS.DEMAND]: '<span class="market-status status-demand">需要↑</span>',
                [PRICE_PATTERNS.DECLINE]: '<span class="market-status status-decline">需要↓</span>'
            };
            return badges[pattern] || '';
        }

        // Start price update timer
        function startPriceUpdateTimer() {
            let countdown = 10;
            
            const updateDisplay = async () => {
                countdown--;
                document.getElementById('next-update').textContent = countdown;
                
                if (countdown <= 0) {
                    countdown = 10;
                    
                    // Check for server-side updates first
                    const now = Date.now();
                    const pricesRef = doc(db, 'cardShopPrices', 'current');
                    
                    try {
                        const snap = await getDoc(pricesRef);
                        if (snap.exists()) {
                            const lastUpdate = snap.data().lastUpdate?.toMillis() || 0;
                            const tenSeconds = 10 * 1000;
                            
                            // If last update was more than 10 seconds ago, update prices
                            if (now - lastUpdate >= tenSeconds) {
                                await updateCardPrices();
                            } else {
                                // Just load the existing prices from server
                                cardPrices = snap.data().prices || {};
                                displayCards();
                                displayInventory();
                                generateMarketPrediction();
                            }
                        } else {
                            // No prices exist yet, create them
                            await updateCardPrices();
                        }
                    } catch (error) {
                        console.error('Error checking prices:', error);
                    }
                }
            };
            
            updateDisplay();
            updateInterval = setInterval(updateDisplay, 1000);
        }


        // Show price history chart for a card
        window.showPriceHistory = (cardId) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            if (!card || !price) return;
            
            // Update modal header
            document.getElementById('chartCardName').textContent = card.name;
            document.getElementById('chartCurrentPrice').textContent = price.current.toLocaleString() + ' pt';
            document.getElementById('chartBasePrice').textContent = card.basePrice.toLocaleString() + ' pt';
            
            // Calculate min/max from history
            const allPrices = price.history.map(h => h.price).concat(price.current);
            const maxPrice = Math.max(...allPrices);
            const minPrice = Math.min(...allPrices);
            
            document.getElementById('chartMaxPrice').textContent = maxPrice.toLocaleString() + ' pt';
            document.getElementById('chartMinPrice').textContent = minPrice.toLocaleString() + ' pt';
            
            // Prepare chart data
            const labels = price.history.map(h => {
                const date = new Date(h.timestamp);
                return `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
            });
            labels.push('現在');
            
            const data = price.history.map(h => h.price);
            data.push(price.current);
            
            // Create or update chart
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            // Destroy existing chart if any
            if (window.priceChartInstance) {
                window.priceChartInstance.destroy();
            }
            
            window.priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '価格推移',
                        data: data,
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        borderWidth: 3,
                        tension: 0.3,
                        pointBackgroundColor: '#2563eb',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }, {
                        label: '基本価格',
                        data: new Array(data.length).fill(card.basePrice),
                        borderColor: 'rgba(239, 68, 68, 0.3)',
                        backgroundColor: 'transparent',
                        borderDash: [10, 5],
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                font: {
                                    size: 14
                                },
                                padding: 15
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            padding: 12,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' pt';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                font: {
                                    size: 12
                                },
                                padding: 8,
                                callback: function(value) {
                                    return value.toLocaleString() + ' pt';
                                }
                            }
                        },
                        x: {
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                },
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('priceHistoryModal'));
            modal.show();
        };

        // Reset all prices to base prices
        window.resetPrices = async () => {
            if (!confirm('本当に全てのカード価格を基本価格にリセットしますか？\nこの操作は取り消せません。')) {
                return;
            }

            document.getElementById('loading').classList.add('active');
            
            try {
                // Reset all prices to base prices
                CARDS_DATABASE.forEach(card => {
                    cardPrices[card.id] = {
                        current: card.basePrice,
                        previous: card.basePrice,
                        pattern: PRICE_PATTERNS.SUPPLY,
                        patternStart: Date.now(),
                        continuationCount: 0,
                        history: []
                    };
                });
                
                // Save to Firebase
                await savePrices();
                
                // Update display
                displayCards();
                displayInventory();
                
                // Show success message
                const toast = document.createElement('div');
                toast.className = 'alert alert-success position-fixed top-50 start-50 translate-middle';
                toast.style.zIndex = '9999';
                toast.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i>価格を基本価格にリセットしました！';
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
                
            } catch (error) {
                console.error('Price reset failed:', error);
                const toast = document.createElement('div');
                toast.className = 'alert alert-danger position-fixed top-50 start-50 translate-middle';
                toast.style.zIndex = '9999';
                toast.innerHTML = '<i class="bi bi-x-circle-fill me-2"></i>価格リセットに失敗しました';
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            } finally {
                document.getElementById('loading').classList.remove('active');
            }
        };

        // Wait for DOM ready to add all event listeners
        window.addEventListener('DOMContentLoaded', () => {
            // Sort change handler
            document.getElementById('sort-select').addEventListener('change', displayCards);
            
            // News source change handler
            document.getElementById('news-source').addEventListener('change', async (e) => {
                const newSource = e.target.value;
                const oldSource = selectedNewsSource;
                
                // Check if switching to paid note
                if (newSource === 'paidNote') {
                    if (!confirm(`有料noteを購読しますか？\n毎日${NEWS_SOURCES.paidNote.cost}ポイントが自動で消費されます。`)) {
                        e.target.value = oldSource;
                        return;
                    }
                    isSubscribedToPaidNote = true;
                } else {
                    isSubscribedToPaidNote = false;
                }
                
                selectedNewsSource = newSource;
                generateMarketPrediction(); // Regenerate prediction with new accuracy
            });
            
            // Login functionality  
            document.getElementById('login-btn').addEventListener('click', async () => {
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                const authError = document.getElementById('auth-error');
                
                if (email === 'local') {
                    currentUser = { uid: 'local_user', email: 'local@example.com' };
                    if (authModal) authModal.hide();
                    return;
                }
                
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    authError.style.display = 'none';
                } catch (error) { 
                    authError.textContent = `ログインエラー: ${error.message}`; 
                    authError.style.display = 'block';
                }
            });
            
            // Signup functionality
            document.getElementById('signup-btn').addEventListener('click', async () => {
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                const authError = document.getElementById('auth-error');
                try {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const gamificationRef = doc(db, 'userGamification', userCredential.user.uid);
                    await setDoc(gamificationRef, {
                        userPoints: 100,  // Use 'userPoints' to match card_list.html
                        totalEarned: 100,
                        totalSpent: 0,
                        lastLogin: serverTimestamp(),
                        createdAt: serverTimestamp()
                    });
                    authError.style.display = 'none';
                } catch (error) {
                    authError.textContent = `新規登録エラー: ${error.message}`;
                    authError.style.display = 'block';
                }
            });
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>
