<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カードショップ - Card Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .shop-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .shop-title {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .points-display {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #d4af37 0%, #b8941f 100%);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        @media (max-width: 992px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .cards-section, .inventory-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .section-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .shop-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .shop-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            border-color: #667eea;
        }
        
        .card-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .card-rarity {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }
        
        .rarity-N { background: #e0e0e0; color: #333; }
        .rarity-R { background: #3498db; color: white; }
        .rarity-SR { background: #e67e22; color: white; }
        .rarity-UR { background: #e74c3c; color: white; }
        .rarity-Secret { background: linear-gradient(45deg, #f39c12, #f1c40f); color: white; }
        
        .card-price {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2ecc71;
            margin-bottom: 5px;
        }
        
        .price-change {
            font-size: 0.9rem;
            margin-left: 5px;
        }
        
        .price-up { color: #e74c3c; }
        .price-down { color: #3498db; }
        .price-stable { color: #95a5a6; }
        
        .buy-button {
            width: 100%;
            margin-top: 10px;
        }
        
        .inventory-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        .inventory-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .profit { color: #2ecc71; }
        .loss { color: #e74c3c; }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .back-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .market-status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-left: 10px;
        }
        
        .status-supply { background: #ecf0f1; color: #7f8c8d; }
        .status-reprint { background: #3498db; color: white; }
        .status-meta { background: #9b59b6; color: white; }
        .status-tournament { background: #e74c3c; color: white; }
        .status-demand { background: #f39c12; color: white; }
        .status-decline { background: #95a5a6; color: white; }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <button class="back-button" onclick="window.location.href='card_list.html'">
        <i class="bi bi-arrow-left"></i> カード管理に戻る
    </button>

    <div class="shop-container">
        <div class="header-section">
            <h1 class="shop-title">
                <i class="bi bi-shop"></i> カードショップ
            </h1>
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                <div class="points-display">
                    <i class="bi bi-coin" style="font-size: 1.5rem; margin-right: 10px;"></i>
                    <span id="current-points">0</span> ポイント
                </div>
                <div>
                    <span class="badge bg-info">次の価格更新まで: <span id="next-update">30:00</span></span>
                    <button class="btn btn-outline-primary btn-sm ms-2" onclick="refreshPrices()">
                        <i class="bi bi-arrow-clockwise"></i> 価格更新
                    </button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="cards-section">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2 class="section-title">
                        <i class="bi bi-cart3"></i> 販売中のカード
                    </h2>
                    <div>
                        <select class="form-select form-select-sm" id="sort-select">
                            <option value="name">名前順</option>
                            <option value="price-asc">価格: 安い順</option>
                            <option value="price-desc">価格: 高い順</option>
                            <option value="rarity">レアリティ順</option>
                        </select>
                    </div>
                </div>
                <div class="card-grid" id="cards-container">
                    <!-- Cards will be dynamically loaded here -->
                </div>
            </div>

            <div class="inventory-section">
                <h2 class="section-title">
                    <i class="bi bi-box-seam"></i> インベントリ
                </h2>
                <div class="mb-3">
                    <div class="alert alert-info mb-2">
                        <small>保有カード: <span id="inventory-count">0</span>枚</small><br>
                        <small>総投資額: <span id="total-invested">0</span>pt</small><br>
                        <small>現在価値: <span id="current-value">0</span>pt</small><br>
                        <small>損益: <span id="profit-loss" class="fw-bold">0</span>pt</small>
                    </div>
                </div>
                <div id="inventory-container">
                    <!-- Inventory items will be dynamically loaded here -->
                </div>
            </div>
        </div>
    </div>

    <div class="loading-overlay active" id="loading">
        <div class="spinner"></div>
    </div>

    <!-- Login Modal -->
    <div class="modal fade" id="auth-modal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1">
        <div class="modal-dialog"><div class="modal-content">
            <div class="modal-header"><h5 class="modal-title">ログインまたは新規登録</h5></div>
            <div class="modal-body">
                <div id="auth-error" class="alert alert-danger" style="display: none;"></div>
                <form id="auth-form">
                    <div class="mb-3"><label for="email" class="form-label">メールアドレス</label><input type="email" class="form-control" id="email" required></div>
                    <div class="mb-3"><label for="password" class="form-label">パスワード</label><input type="password" class="form-control" id="password" required></div>
                    <div class="d-grid gap-2">
                        <button type="button" id="login-btn" class="btn btn-primary">ログイン</button>
                        <button type="button" id="signup-btn" class="btn btn-secondary">新規登録</button>
                    </div>
                </form>
            </div>
        </div></div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { 
            getAuth, 
            onAuthStateChanged,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            setPersistence,
            browserLocalPersistence
        } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';
        import { 
            getFirestore, 
            doc, 
            getDoc,
            setDoc,
            updateDoc,
            collection,
            query,
            where,
            getDocs,
            addDoc,
            deleteDoc,
            serverTimestamp
        } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';

        // Firebase configuration (same as card_list.html)
        const firebaseConfig = {
            apiKey: "AIzaSyAOYKalLUb2hbghrjQUS8AWzxpLExBT7aU",
            authDomain: "ygoh-9bcf6.firebaseapp.com",
            projectId: "ygoh-9bcf6",
            storageBucket: "ygoh-9bcf6.firebasestorage.app",
            messagingSenderId: "515041224138",
            appId: "1:515041224138:web:8de47b38ed9cc1bb8afd37",
            measurementId: "G-ZGSRE8MHZ2"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Set persistence to LOCAL (keeps user logged in)
        setPersistence(auth, browserLocalPersistence).catch((error) => {
            console.error('Error setting persistence:', error);
        });

        let currentUser = null;
        let userPoints = 0;
        let isSpinning = false;
        let authChecked = false;
        let inventory = [];
        let cardPrices = {};
        let updateInterval = null;

        // Virtual card database
        const CARDS_DATABASE = [
            { id: 'card-001', name: '黒魔女ディアベルスター', rarity: 'QCSE', basePrice: 9000 },
            { id: 'card-002', name: 'ユベル', rarity: 'SR', basePrice: 300 },
            { id: 'card-003', name: '反逆の罪宝－スネークアイ', rarity: 'SE', basePrice: 1500 },
            { id: 'card-004', name: '青眼の白龍', rarity: 'SE', basePrice: 30000 },
            { id: 'card-005', name: 'ブラック・マジシャン', rarity: 'SE', basePrice: 2500 },
            { id: 'card-006', name: '真紅眼の黒竜', rarity: 'UR', basePrice: 1500 },
            { id: 'card-007', name: '封印されしエクゾディア', rarity: 'UR', basePrice: 800 },
            { id: 'card-008', name: '黄金卿エルドリッチ', rarity: 'UR', basePrice: 600 },
            { id: 'card-009', name: 'カオス・ソルジャー－開闢の使者－', rarity: 'UR', basePrice: 800 },
            { id: 'card-010', name: '青眼の亜白龍', rarity: 'SE', basePrice: 400 },
            { id: 'card-011', name: 'I:Pマスカレーナ', rarity: 'PSE', basePrice: 25000 },
            { id: 'card-012', name: 'アクセスコード・トーカー', rarity: 'SE', basePrice: 800 },
            { id: 'card-013', name: '灰流うらら', rarity: 'SR', basePrice: 400 },
            { id: 'card-014', name: '増殖するG', rarity: 'SR', basePrice: 400 },
            { id: 'card-015', name: '神の宣告', rarity: 'UR', basePrice: 200 },
            { id: 'card-016', name: 'ブラック・マジシャン・ガール', rarity: 'UR', basePrice: 700 },
            { id: 'card-017', name: '無限泡影', rarity: 'UR', basePrice: 800 },
            { id: 'card-018', name: '月女神の鏃', rarity: 'UR', basePrice: 500 },
            { id: 'card-019', name: 'マルチャミー・フワロス', rarity: 'R', basePrice: 1300 }
        ];

        // Price fluctuation patterns
        const PRICE_PATTERNS = {
            SUPPLY: 'supply',      // 市場供給量の変化
            REPRINT: 'reprint',    // 再録
            META: 'meta',          // 環境の変化
            TOURNAMENT: 'tournament', // 大会での結果
            DEMAND: 'demand',      // 需要増加
            DECLINE: 'decline'     // 需要低下
        };

        // Initialize
        let authModal = null;
        
        // Wait for DOM to be ready before setting up auth
        window.addEventListener('DOMContentLoaded', () => {
            const authModalElement = document.getElementById('auth-modal');
            
            if (authModalElement) {
                authModal = new bootstrap.Modal(authModalElement);
            }
            
            // Setup auth state listener
            onAuthStateChanged(auth, async (user) => {
                console.log('Auth state changed:', user ? 'User logged in' : 'No user');
                if (user) {
                    currentUser = user;
                    // Hide modal if it exists
                    if (authModal) {
                        authModal.hide();
                    }
                    await loadUserData();
                    await loadCardPrices();
                    await loadInventory();
                    displayCards();
                    displayInventory();
                    startPriceUpdateTimer();
                    document.getElementById('loading').classList.remove('active');
                } else {
                    // User not logged in - show login modal
                    document.getElementById('loading').classList.remove('active');
                    if (authModal) {
                        authModal.show();
                    }
                }
            });
        });

        // Load user points
        async function loadUserData() {
            try {
                const gamificationRef = doc(db, 'userGamification', currentUser.uid);
                const gamificationSnap = await getDoc(gamificationRef);
                
                if (gamificationSnap.exists()) {
                    const data = gamificationSnap.data();
                    // card_list.html uses 'userPoints' field
                    userPoints = data.userPoints || data.points || 0;
                    document.getElementById('current-points').textContent = userPoints.toLocaleString();
                }
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        }

        // Save user points
        async function saveUserPoints() {
            try {
                const gamificationRef = doc(db, 'userGamification', currentUser.uid);
                // Use 'userPoints' field to match card_list.html
                await updateDoc(gamificationRef, { userPoints: userPoints });
                document.getElementById('current-points').textContent = userPoints.toLocaleString();
            } catch (error) {
                console.error('Error saving points:', error);
            }
        }

        // Load or initialize card prices
        async function loadCardPrices() {
            try {
                const pricesRef = doc(db, 'cardShopPrices', 'current');
                const pricesSnap = await getDoc(pricesRef);
                
                const now = Date.now();
                const thirtyMinutes = 30 * 60 * 1000;
                
                if (pricesSnap.exists()) {
                    const data = pricesSnap.data();
                    const lastUpdate = data.lastUpdate?.toMillis() || 0;
                    
                    // Update prices if 30 minutes have passed
                    if (now - lastUpdate >= thirtyMinutes) {
                        await updateCardPrices();
                    } else {
                        cardPrices = data.prices || {};
                        // Initialize missing prices
                        CARDS_DATABASE.forEach(card => {
                            if (!cardPrices[card.id]) {
                                cardPrices[card.id] = {
                                    current: card.basePrice,
                                    previous: card.basePrice,
                                    pattern: PRICE_PATTERNS.SUPPLY,
                                    patternStart: now,
                                    history: []
                                };
                            }
                        });
                    }
                } else {
                    // Initialize all prices
                    CARDS_DATABASE.forEach(card => {
                        cardPrices[card.id] = {
                            current: card.basePrice,
                            previous: card.basePrice,
                            pattern: PRICE_PATTERNS.SUPPLY,
                            patternStart: now,
                            history: []
                        };
                    });
                    await savePrices();
                }
            } catch (error) {
                console.error('Error loading prices:', error);
            }
        }

        // Update card prices based on patterns
        async function updateCardPrices() {
            const now = Date.now();
            
            CARDS_DATABASE.forEach(card => {
                const price = cardPrices[card.id] || {
                    current: card.basePrice,
                    previous: card.basePrice,
                    pattern: PRICE_PATTERNS.SUPPLY,
                    patternStart: now,
                    history: []
                };
                
                // Save previous price
                price.previous = price.current;
                price.history.push({
                    price: price.current,
                    timestamp: now
                });
                
                // Keep only last 10 history entries
                if (price.history.length > 10) {
                    price.history.shift();
                }
                
                // Determine next pattern based on current pattern
                let nextPattern = price.pattern;
                const rand = Math.random();
                
                switch (price.pattern) {
                    case PRICE_PATTERNS.SUPPLY:
                        // 60% chance to continue supply pattern
                        if (rand > 0.6) {
                            const patterns = [PRICE_PATTERNS.META, PRICE_PATTERNS.TOURNAMENT, PRICE_PATTERNS.DEMAND];
                            nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        }
                        break;
                    
                    case PRICE_PATTERNS.REPRINT:
                        // 80% chance to continue reprint pattern
                        if (rand > 0.8) {
                            nextPattern = PRICE_PATTERNS.SUPPLY;
                        }
                        break;
                    
                    case PRICE_PATTERNS.TOURNAMENT:
                        // 30% chance to continue tournament, else decline
                        nextPattern = rand < 0.3 ? PRICE_PATTERNS.TOURNAMENT : PRICE_PATTERNS.DECLINE;
                        break;
                    
                    case PRICE_PATTERNS.DEMAND:
                        // 40% chance to continue demand, else decline
                        nextPattern = rand < 0.4 ? PRICE_PATTERNS.DEMAND : PRICE_PATTERNS.DECLINE;
                        break;
                    
                    case PRICE_PATTERNS.DECLINE:
                        // 60% chance to continue decline
                        if (rand > 0.6) {
                            const patterns = [PRICE_PATTERNS.META, PRICE_PATTERNS.SUPPLY];
                            nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        }
                        break;
                    
                    case PRICE_PATTERNS.META:
                        // Random next pattern
                        if (rand < 0.3) {
                            const patterns = Object.values(PRICE_PATTERNS);
                            nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        }
                        break;
                    
                    default:
                        // Initialize with random pattern
                        const patterns = Object.values(PRICE_PATTERNS);
                        nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                        break;
                }
                
                // Change pattern if different
                if (nextPattern !== price.pattern) {
                    price.pattern = nextPattern;
                    price.patternStart = now;
                }
                
                // Apply price changes based on pattern
                let multiplier = 1;
                const rarityMultiplier = {
                    'R': 1.0,
                    'SR': 0.9,
                    'UR': 0.85,
                    'SE': 0.8,
                    'PSE': 0.75,
                    'QCSE': 0.7
                };
                
                switch (price.pattern) {
                    case PRICE_PATTERNS.SUPPLY:
                        // Gradual decrease
                        multiplier = 0.93 + Math.random() * 0.04; // 0.93-0.97
                        break;
                    
                    case PRICE_PATTERNS.REPRINT:
                        // Sharp decrease, less for higher rarity
                        const rarityMod = rarityMultiplier[card.rarity] || 1;
                        multiplier = 0.5 + (0.3 * rarityMod); // 0.5-0.8 depending on rarity
                        break;
                    
                    case PRICE_PATTERNS.META:
                        // Random fluctuation up or down
                        multiplier = 0.85 + Math.random() * 0.3; // 0.85-1.15
                        break;
                    
                    case PRICE_PATTERNS.TOURNAMENT:
                        // Sharp increase
                        multiplier = 1.35 + Math.random() * 0.25; // 1.35-1.60
                        break;
                    
                    case PRICE_PATTERNS.DEMAND:
                        // Gradual increase then stable
                        const timeSinceDemand = now - price.patternStart;
                        if (timeSinceDemand < 60 * 60 * 1000) { // First hour
                            multiplier = 1.08 + Math.random() * 0.07; // 1.08-1.15
                        } else {
                            multiplier = 0.98 + Math.random() * 0.04; // 0.98-1.02 (stable)
                        }
                        break;
                    
                    case PRICE_PATTERNS.DECLINE:
                        // Gradual decrease
                        multiplier = 0.92 + Math.random() * 0.04; // 0.92-0.96
                        break;
                }
                
                // Apply multiplier with minimum price (10% of base) and no maximum cap
                price.current = Math.max(
                    Math.floor(card.basePrice * 0.1), // Minimum 10% of base price
                    Math.floor(price.current * multiplier)
                );
                
                cardPrices[card.id] = price;
            });
            
            await savePrices();
            displayCards();
            updateInventoryDisplay();
        }

        // Save prices to Firestore
        async function savePrices() {
            try {
                await setDoc(doc(db, 'cardShopPrices', 'current'), {
                    prices: cardPrices,
                    lastUpdate: serverTimestamp()
                });
            } catch (error) {
                console.error('Error saving prices:', error);
            }
        }

        // Load user inventory
        async function loadInventory() {
            try {
                const inventoryRef = collection(db, 'userInventory', currentUser.uid, 'cards');
                const inventorySnap = await getDocs(inventoryRef);
                
                inventory = [];
                inventorySnap.forEach(doc => {
                    inventory.push({
                        docId: doc.id,
                        ...doc.data()
                    });
                });
            } catch (error) {
                console.error('Error loading inventory:', error);
            }
        }

        // Buy card with quantity selection
        window.buyCard = async (cardId, quantity = null) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            if (!card || !price) return;
            
            // If quantity not specified, show quantity selector
            if (quantity === null) {
                const quantities = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                const maxQty = Math.floor(userPoints / price.current);
                
                if (maxQty === 0) {
                    alert('ポイントが不足しています！');
                    return;
                }
                
                // Create quantity buttons
                const quantityHTML = quantities
                    .filter(q => q <= maxQty)
                    .map(q => `<button class="btn btn-sm btn-outline-primary mx-1" onclick="buyCard('${cardId}', ${q})">${q}枚</button>`)
                    .join('');
                
                const modal = document.createElement('div');
                modal.className = 'modal fade show';
                modal.style.display = 'block';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${card.name} を購入</h5>
                                <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                            </div>
                            <div class="modal-body">
                                <p>価格: ${price.current.toLocaleString()} pt/枚</p>
                                <p>最大購入可能: ${maxQty}枚</p>
                                <div class="d-flex flex-wrap justify-content-center mt-3">
                                    ${quantityHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                return;
            }
            
            // Buy specified quantity
            const totalCost = price.current * quantity;
            if (userPoints < totalCost) {
                alert('ポイントが不足しています！');
                return;
            }
            
            userPoints -= totalCost;
            await saveUserPoints();
            
            // Add multiple cards to inventory
            const inventoryRef = collection(db, 'userInventory', currentUser.uid, 'cards');
            const promises = [];
            for (let i = 0; i < quantity; i++) {
                promises.push(addDoc(inventoryRef, {
                    cardId: cardId,
                    purchasePrice: price.current,
                    purchaseTime: serverTimestamp()
                }));
            }
            await Promise.all(promises);
            
            await loadInventory();
            displayInventory();
            
            // Remove modal if exists
            const modal = document.querySelector('.modal.show');
            if (modal) modal.remove();
            
            // Show success message briefly
            const toast = document.createElement('div');
            toast.className = 'alert alert-success position-fixed top-50 start-50 translate-middle';
            toast.style.zIndex = '9999';
            toast.innerHTML = `<strong>${card.name}</strong> を ${quantity}枚 購入しました！`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        };

        // Sell card with quantity selection for stacked cards
        window.sellCard = async (cardId, purchasePrice = null) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            if (!card || !price) return;
            
            // Get all cards with same ID and purchase price
            let itemsToSell = inventory.filter(item => item.cardId === cardId);
            
            if (purchasePrice !== null) {
                itemsToSell = itemsToSell.filter(item => item.purchasePrice === purchasePrice);
            }
            
            if (itemsToSell.length === 0) return;
            
            const profit = price.current - (purchasePrice || itemsToSell[0].purchasePrice);
            const profitText = profit >= 0 ? `+${profit}` : profit;
            const profitClass = profit >= 0 ? 'text-success' : 'text-danger';
            
            // If multiple items with same price, show quantity selector
            if (itemsToSell.length > 1) {
                const modal = document.createElement('div');
                modal.className = 'modal fade show';
                modal.style.display = 'block';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                
                const quantityButtons = [];
                for (let i = 1; i <= Math.min(itemsToSell.length, 9); i++) {
                    const totalProfit = profit * i;
                    const totalRevenue = price.current * i;
                    quantityButtons.push(`
                        <button class="btn btn-sm btn-outline-danger mx-1 mb-2" 
                                onclick="sellMultiple('${cardId}', ${purchasePrice || itemsToSell[0].purchasePrice}, ${i})">
                            ${i}枚 (${totalRevenue.toLocaleString()}pt)
                        </button>
                    `);
                }
                
                modal.innerHTML = `
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${card.name} を売却</h5>
                                <button type="button" class="btn-close" onclick="this.closest('.modal').remove()"></button>
                            </div>
                            <div class="modal-body">
                                <p>現在価格: ${price.current.toLocaleString()} pt/枚</p>
                                <p>購入価格: ${(purchasePrice || itemsToSell[0].purchasePrice).toLocaleString()} pt/枚</p>
                                <p class="${profitClass}">損益: ${profitText} pt/枚</p>
                                <p>所持数: ${itemsToSell.length}枚</p>
                                <div class="d-flex flex-wrap justify-content-center mt-3">
                                    ${quantityButtons.join('')}
                                </div>
                                <button class="btn btn-danger w-100 mt-2" 
                                        onclick="sellMultiple('${cardId}', ${purchasePrice || itemsToSell[0].purchasePrice}, ${itemsToSell.length})">
                                    全て売却 (${itemsToSell.length}枚)
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                // Single item, sell directly
                await sellMultiple(cardId, purchasePrice || itemsToSell[0].purchasePrice, 1);
            }
        };
        
        // Sell multiple cards
        window.sellMultiple = async (cardId, purchasePrice, quantity) => {
            const card = CARDS_DATABASE.find(c => c.id === cardId);
            const price = cardPrices[cardId];
            
            const itemsToSell = inventory
                .filter(item => item.cardId === cardId && item.purchasePrice === purchasePrice)
                .slice(0, quantity);
            
            if (itemsToSell.length === 0) return;
            
            const totalRevenue = price.current * itemsToSell.length;
            userPoints += totalRevenue;
            await saveUserPoints();
            
            // Delete items from inventory
            const deletePromises = itemsToSell.map(item => 
                deleteDoc(doc(db, 'userInventory', currentUser.uid, 'cards', item.docId))
            );
            await Promise.all(deletePromises);
            
            await loadInventory();
            displayInventory();
            
            // Remove modal
            const modal = document.querySelector('.modal.show');
            if (modal) modal.remove();
            
            // Show success message
            const profit = (price.current - purchasePrice) * itemsToSell.length;
            const toast = document.createElement('div');
            toast.className = `alert alert-${profit >= 0 ? 'success' : 'warning'} position-fixed top-50 start-50 translate-middle`;
            toast.style.zIndex = '9999';
            toast.innerHTML = `
                <strong>${card.name}</strong> を ${itemsToSell.length}枚 売却しました！<br>
                獲得: ${totalRevenue.toLocaleString()} pt<br>
                損益: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()} pt
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        };

        // Display cards in shop
        function displayCards() {
            const container = document.getElementById('cards-container');
            const sortSelect = document.getElementById('sort-select');
            
            let sortedCards = [...CARDS_DATABASE];
            
            // Apply sorting
            switch (sortSelect.value) {
                case 'price-asc':
                    sortedCards.sort((a, b) => cardPrices[a.id].current - cardPrices[b.id].current);
                    break;
                case 'price-desc':
                    sortedCards.sort((a, b) => cardPrices[b.id].current - cardPrices[a.id].current);
                    break;
                case 'rarity':
                    const rarityOrder = { 'N': 0, 'R': 1, 'SR': 2, 'UR': 3, 'Secret': 4 };
                    sortedCards.sort((a, b) => rarityOrder[b.rarity] - rarityOrder[a.rarity]);
                    break;
                default:
                    sortedCards.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            container.innerHTML = sortedCards.map(card => {
                const price = cardPrices[card.id];
                const priceChange = price.current - price.previous;
                const priceChangeClass = priceChange > 0 ? 'price-up' : priceChange < 0 ? 'price-down' : 'price-stable';
                const priceChangeIcon = priceChange > 0 ? '↑' : priceChange < 0 ? '↓' : '→';
                const priceChangeText = priceChange !== 0 ? Math.abs(priceChange) : '';
                
                const patternBadge = getPatternBadge(price.pattern);
                
                return `
                    <div class="shop-card">
                        <div class="card-name">${card.name}</div>
                        <span class="card-rarity rarity-${card.rarity}">${card.rarity}</span>
                        ${patternBadge}
                        <div class="card-price">
                            ${price.current.toLocaleString()} pt
                            <span class="price-change ${priceChangeClass}">
                                ${priceChangeIcon} ${priceChangeText}
                            </span>
                        </div>
                        <button class="btn btn-primary buy-button" onclick="buyCard('${card.id}')">
                            <i class="bi bi-cart-plus"></i> 購入
                        </button>
                    </div>
                `;
            }).join('');
        }

        // Display inventory with stacking
        function displayInventory() {
            const container = document.getElementById('inventory-container');
            
            if (inventory.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">カードを所有していません</p>';
                updateInventoryStats();
                return;
            }
            
            // Group inventory by cardId and purchasePrice
            const groupedInventory = {};
            inventory.forEach(item => {
                const key = `${item.cardId}_${item.purchasePrice}`;
                if (!groupedInventory[key]) {
                    groupedInventory[key] = {
                        cardId: item.cardId,
                        purchasePrice: item.purchasePrice,
                        items: [],
                        earliestDate: item.purchaseTime
                    };
                }
                groupedInventory[key].items.push(item);
                if (item.purchaseTime < groupedInventory[key].earliestDate) {
                    groupedInventory[key].earliestDate = item.purchaseTime;
                }
            });
            
            // Add "Sell all profitable" button if there are profitable cards
            const profitableGroups = Object.values(groupedInventory).filter(group => {
                const price = cardPrices[group.cardId];
                return price && price.current > group.purchasePrice;
            });
            
            let headerHTML = '';
            if (profitableGroups.length > 0) {
                const totalProfit = profitableGroups.reduce((sum, group) => {
                    const price = cardPrices[group.cardId];
                    return sum + ((price.current - group.purchasePrice) * group.items.length);
                }, 0);
                
                headerHTML = `
                    <button class="btn btn-success btn-sm w-100 mb-3" onclick="sellAllProfitable()">
                        <i class="bi bi-graph-up"></i> 利益カード全売却 (+${totalProfit.toLocaleString()}pt)
                    </button>
                `;
            }
            
            // Display grouped inventory
            const inventoryHTML = Object.values(groupedInventory).map(group => {
                const card = CARDS_DATABASE.find(c => c.id === group.cardId);
                const price = cardPrices[group.cardId];
                
                if (!card || !price) return '';
                
                const profit = price.current - group.purchasePrice;
                const profitClass = profit >= 0 ? 'profit' : 'loss';
                const profitText = profit >= 0 ? `+${profit}` : profit;
                const totalProfit = profit * group.items.length;
                
                const purchaseDate = group.earliestDate?.toDate ? 
                    new Date(group.earliestDate.toDate()).toLocaleDateString('ja-JP') : 
                    '不明';
                
                const countBadge = group.items.length > 1 ? 
                    `<span class="badge bg-primary ms-2">${group.items.length}枚</span>` : '';
                
                return `
                    <div class="inventory-item">
                        <div class="inventory-item-header">
                            <strong>${card.name}${countBadge}</strong>
                            <span class="card-rarity rarity-${card.rarity}">${card.rarity}</span>
                        </div>
                        <div class="small text-muted">初回購入: ${purchaseDate}</div>
                        <div class="small">購入価格: ${group.purchasePrice.toLocaleString()}pt/枚</div>
                        <div class="small">現在価格: ${price.current.toLocaleString()}pt/枚</div>
                        <div class="small ${profitClass} fw-bold">
                            損益: ${profitText}pt/枚
                            ${group.items.length > 1 ? `(計: ${totalProfit >= 0 ? '+' : ''}${totalProfit.toLocaleString()}pt)` : ''}
                        </div>
                        <button class="btn btn-danger btn-sm w-100 mt-2" onclick="sellCard('${group.cardId}', ${group.purchasePrice})">
                            <i class="bi bi-cash"></i> 売却
                        </button>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = headerHTML + inventoryHTML;
            updateInventoryStats();
        }
        
        // Sell all profitable cards
        window.sellAllProfitable = async () => {
            const profitableItems = inventory.filter(item => {
                const price = cardPrices[item.cardId];
                return price && price.current > item.purchasePrice;
            });
            
            if (profitableItems.length === 0) {
                alert('利益が出ているカードがありません。');
                return;
            }
            
            const totalRevenue = profitableItems.reduce((sum, item) => {
                const price = cardPrices[item.cardId];
                return sum + price.current;
            }, 0);
            
            const totalProfit = profitableItems.reduce((sum, item) => {
                const price = cardPrices[item.cardId];
                return sum + (price.current - item.purchasePrice);
            }, 0);
            
            if (confirm(`利益が出ているカード ${profitableItems.length}枚 を全て売却しますか？\n\n獲得予定: ${totalRevenue.toLocaleString()}pt\n利益予定: +${totalProfit.toLocaleString()}pt`)) {
                userPoints += totalRevenue;
                await saveUserPoints();
                
                // Delete all profitable items
                const deletePromises = profitableItems.map(item => 
                    deleteDoc(doc(db, 'userInventory', currentUser.uid, 'cards', item.docId))
                );
                await Promise.all(deletePromises);
                
                await loadInventory();
                displayInventory();
                
                // Show success message
                const toast = document.createElement('div');
                toast.className = 'alert alert-success position-fixed top-50 start-50 translate-middle';
                toast.style.zIndex = '9999';
                toast.innerHTML = `
                    <strong>利益カード ${profitableItems.length}枚 を売却しました！</strong><br>
                    獲得: ${totalRevenue.toLocaleString()} pt<br>
                    利益: +${totalProfit.toLocaleString()} pt
                `;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }
        };

        // Update inventory statistics
        function updateInventoryStats() {
            let totalInvested = 0;
            let currentValue = 0;
            
            inventory.forEach(item => {
                totalInvested += item.purchasePrice;
                const price = cardPrices[item.cardId];
                if (price) {
                    currentValue += price.current;
                }
            });
            
            const profitLoss = currentValue - totalInvested;
            const profitLossClass = profitLoss >= 0 ? 'profit' : 'loss';
            
            document.getElementById('inventory-count').textContent = inventory.length;
            document.getElementById('total-invested').textContent = totalInvested.toLocaleString();
            document.getElementById('current-value').textContent = currentValue.toLocaleString();
            
            const profitLossElement = document.getElementById('profit-loss');
            profitLossElement.textContent = (profitLoss >= 0 ? '+' : '') + profitLoss.toLocaleString();
            profitLossElement.className = `fw-bold ${profitLossClass}`;
        }

        // Update inventory display only
        function updateInventoryDisplay() {
            const container = document.getElementById('inventory-container');
            if (inventory.length > 0) {
                displayInventory();
            }
        }

        // Get pattern badge HTML
        function getPatternBadge(pattern) {
            const badges = {
                [PRICE_PATTERNS.SUPPLY]: '<span class="market-status status-supply">供給</span>',
                [PRICE_PATTERNS.REPRINT]: '<span class="market-status status-reprint">再録</span>',
                [PRICE_PATTERNS.META]: '<span class="market-status status-meta">環境</span>',
                [PRICE_PATTERNS.TOURNAMENT]: '<span class="market-status status-tournament">大会</span>',
                [PRICE_PATTERNS.DEMAND]: '<span class="market-status status-demand">需要↑</span>',
                [PRICE_PATTERNS.DECLINE]: '<span class="market-status status-decline">需要↓</span>'
            };
            return badges[pattern] || '';
        }

        // Start price update timer
        function startPriceUpdateTimer() {
            const updateDisplay = () => {
                const now = Date.now();
                const pricesRef = doc(db, 'cardShopPrices', 'current');
                
                getDoc(pricesRef).then(snap => {
                    if (snap.exists()) {
                        const lastUpdate = snap.data().lastUpdate?.toMillis() || now;
                        const thirtyMinutes = 30 * 60 * 1000;
                        const nextUpdate = lastUpdate + thirtyMinutes;
                        const remaining = Math.max(0, nextUpdate - now);
                        
                        const minutes = Math.floor(remaining / 60000);
                        const seconds = Math.floor((remaining % 60000) / 1000);
                        
                        document.getElementById('next-update').textContent = 
                            `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        
                        if (remaining === 0) {
                            refreshPrices();
                        }
                    }
                });
            };
            
            updateDisplay();
            updateInterval = setInterval(updateDisplay, 1000);
        }

        // Refresh prices manually
        window.refreshPrices = async () => {
            document.getElementById('loading').classList.add('active');
            await updateCardPrices();
            document.getElementById('loading').classList.remove('active');
        };

        // Wait for DOM ready to add all event listeners
        window.addEventListener('DOMContentLoaded', () => {
            // Sort change handler
            document.getElementById('sort-select').addEventListener('change', displayCards);
            
            // Login functionality  
            document.getElementById('login-btn').addEventListener('click', async () => {
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                const authError = document.getElementById('auth-error');
                
                if (email === 'local') {
                    currentUser = { uid: 'local_user', email: 'local@example.com' };
                    if (authModal) authModal.hide();
                    return;
                }
                
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    authError.style.display = 'none';
                } catch (error) { 
                    authError.textContent = `ログインエラー: ${error.message}`; 
                    authError.style.display = 'block';
                }
            });
            
            // Signup functionality
            document.getElementById('signup-btn').addEventListener('click', async () => {
                const email = document.getElementById('email').value;
                const password = document.getElementById('password').value;
                const authError = document.getElementById('auth-error');
                try {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const gamificationRef = doc(db, 'userGamification', userCredential.user.uid);
                    await setDoc(gamificationRef, {
                        userPoints: 100,  // Use 'userPoints' to match card_list.html
                        totalEarned: 100,
                        totalSpent: 0,
                        lastLogin: serverTimestamp(),
                        createdAt: serverTimestamp()
                    });
                    authError.style.display = 'none';
                } catch (error) {
                    authError.textContent = `新規登録エラー: ${error.message}`;
                    authError.style.display = 'block';
                }
            });
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>
