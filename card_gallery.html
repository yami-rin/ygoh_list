<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カードギャラリー - グリッド表示</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="image_cache_manager.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Navigation bar */
        .navbar-custom {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 0.75rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .navbar-custom.scrolled {
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .navbar-brand {
            font-weight: 700;
            font-size: 1.3rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .navbar-brand i {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
        }

        .nav-link-custom {
            color: #2c3e50;
            font-weight: 500;
            padding: 0.5rem 1rem;
            margin: 0 0.25rem;
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-link-custom:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
        }

        .nav-link-custom.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
        }

        .nav-link-custom i {
            font-size: 1.1rem;
        }

        .header-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 3rem 0 2.5rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .header-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="rgba(255,255,255,0.1)" d="M0,96L48,112C96,128,192,160,288,160C384,160,480,128,576,122.7C672,117,768,139,864,138.7C960,139,1056,117,1152,101.3C1248,85,1344,75,1392,69.3L1440,64L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
            background-size: cover;
            background-position: bottom;
            opacity: 0.3;
            animation: wave 15s ease-in-out infinite;
        }

        @keyframes wave {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(-50px); }
        }

        .header-section h1 {
            position: relative;
            z-index: 1;
            font-size: 2.5rem;
            font-weight: 800;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
            margin-bottom: 0.5rem;
            animation: fadeInDown 0.6s ease-out;
        }

        .header-subtitle {
            position: relative;
            z-index: 1;
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 300;
            animation: fadeInUp 0.6s ease-out 0.2s both;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .controls-bar {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .view-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Grid layout styles */
        .card-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
            transition: margin-left 0.3s ease;
        }

        body.deck-builder-open .header-section,
        body.deck-builder-open .container {
            margin-left: 420px;
            transition: margin-left 0.3s ease;
        }

        .card-grid.size-small {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .card-grid.size-medium {
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        .card-grid.size-large {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .card-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .card-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        /* Unowned card styles */
        .card-item.unowned {
            opacity: 0.7;
            border-color: #ccc;
        }

        .card-item.unowned .card-image-container img {
            filter: grayscale(100%);
        }

        .card-item.unowned:hover {
            opacity: 0.85;
        }

        .card-item.unowned .card-quantity {
            color: #6c757d;
        }

        .unowned-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(108, 117, 125, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 1;
        }

        .card-image-container {
            width: 100%;
            aspect-ratio: 0.686;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .card-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        .card-item:hover .card-image-container img {
            transform: scale(1.05);
        }

        .card-image-placeholder {
            font-size: 4rem;
            color: rgba(0,0,0,0.1);
        }

        .card-image-reload {
            position: absolute;
            bottom: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            z-index: 2;
            transition: background 0.2s;
        }

        .card-image-reload:hover {
            background: rgba(0,0,0,0.9);
        }

        .card-image-reload i {
            margin-right: 0.25rem;
        }

        .card-info {
            padding: 0.75rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .card-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
            min-height: 2.6em;
            color: #2c3e50;
        }

        .card-code {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .card-rarity {
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .card-quantity {
            font-size: 0.9rem;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: auto;
        }

        .card-tags .badge {
            font-size: 0.65rem;
            padding: 0.25rem 0.5rem;
        }

        .stock-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .stats-bar {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-overlay.hidden {
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .card-grid.size-small {
                grid-template-columns: repeat(5, 1fr);
                gap: 0.25rem;
            }

            .card-grid.size-medium {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.75rem;
            }

            .card-grid.size-large {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .card-info {
                padding: 0.5rem;
            }

            .card-name {
                font-size: 0.8rem;
            }

            .controls-bar {
                padding: 0.75rem;
            }

            .view-controls {
                font-size: 0.9rem;
            }
        }

        .filter-section {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .filter-section .form-control,
        .filter-section .form-select {
            font-size: 0.9rem;
        }

        /* Side panel styles */
        .edit-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1050;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .edit-panel-overlay.show {
            display: block;
            opacity: 1;
        }

        .edit-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 90%;
            max-width: 900px;
            height: 100vh;
            background: white;
            z-index: 1051;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.3);
        }

        .edit-panel.show {
            right: 0;
        }

        .edit-panel-content {
            display: flex;
            height: 100%;
            flex-direction: row;
        }

        .edit-panel-left {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
        }

        .edit-panel-left img {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        #illustrationSelector {
            width: 100%;
            max-width: 300px;
        }

        #illustrationOptions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border-radius: 8px;
        }

        .illustration-option {
            width: 60px;
            height: 84px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            transition: all 0.2s;
            object-fit: cover;
        }

        .illustration-option:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .illustration-option.active {
            border-color: #667eea;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.5);
        }

        .edit-panel-right {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            background: white;
        }

        .edit-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .edit-panel-header h3 {
            margin: 0;
            color: #2c3e50;
        }

        .edit-panel-close {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .edit-panel-close:hover {
            background: #f8f9fa;
            color: #000;
        }

        .edit-panel-form .form-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }

        .edit-panel-form .form-control,
        .edit-panel-form .form-control-plaintext {
            margin-bottom: 1.5rem;
        }

        .edit-panel-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #e9ecef;
        }

        .edit-panel-actions button {
            flex: 1;
        }

        /* Deck Builder Panel Styles */
        /* Deck List Panel Styles */
        .deck-list-panel {
            position: fixed;
            top: 0;
            left: -450px;
            width: 450px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 10px rgba(0,0,0,0.2);
            z-index: 1060;
            transition: left 0.3s ease;
            overflow-y: auto;
        }

        .deck-list-panel.active {
            left: 0;
        }

        .deck-list-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .deck-list-header h4 {
            margin: 0;
        }

        .deck-list-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .deck-list-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .deck-list-content {
            padding: 1.5rem;
        }

        .deck-builder-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 10px rgba(0,0,0,0.2);
            z-index: 1050;
            transition: left 0.3s ease;
            overflow-y: auto;
        }

        .deck-builder-panel.active {
            left: 0;
        }

        .deck-builder-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .deck-builder-header h4 {
            margin: 0;
        }

        .deck-builder-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .deck-builder-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .deck-builder-content {
            padding: 1.5rem;
        }

        .deck-info-section {
            margin-bottom: 1.5rem;
        }

        .deck-cards-section {
            margin-bottom: 1.5rem;
        }

        .deck-drop-zone {
            min-height: 300px;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            background: #f8f9fa;
            position: relative;
        }

        .deck-drop-zone.drag-over {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .deck-drop-placeholder {
            text-align: center;
            color: #adb5bd;
            padding: 2rem;
        }

        .deck-drop-placeholder p {
            margin: 0.5rem 0 0 0;
        }

        .deck-cards-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.75rem;
        }

        .deck-card-item {
            transition: all 0.2s;
        }

        .deck-card-item:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .deck-card-item.unowned img {
            filter: grayscale(100%) brightness(0.7);
            opacity: 0.6;
        }

        .deck-card-image-container {
            width: 100%;
            aspect-ratio: 0.686;
            background: #f8f9fa;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .deck-card-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .deck-card-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #adb5bd;
            font-size: 2rem;
        }

        .deck-card-rarity {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            line-height: 1.2;
        }

        .deck-card-code {
            position: absolute;
            bottom: 4px;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            font-size: 0.5rem;
            text-align: center;
            line-height: 1.2;
        }

        /* Hide code and rarity when toggle is off */
        .hide-card-details .deck-card-code,
        .hide-card-details .deck-card-rarity {
            display: none;
        }

        .deck-builder-actions {
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        /* Drag and drop styles */
        .card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .card-item.draggable {
            cursor: grab;
        }

        .deck-card-item {
            cursor: grab;
            position: relative;
        }

        .deck-card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .deck-card-item.drag-over-left {
            border-left: 3px solid #667eea;
        }

        .deck-card-item.drag-over-right {
            border-right: 3px solid #667eea;
        }

        /* Context menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 4px 0;
            z-index: 10000;
            display: none;
            min-width: 180px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            user-select: none;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        .context-menu-item i {
            margin-right: 8px;
            width: 16px;
            display: inline-block;
        }

        .deck-list-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.2s;
        }

        .deck-list-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-color: #667eea;
        }

        .deck-list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.5rem;
        }

        .deck-list-item-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #2c3e50;
            flex: 1;
        }

        .deck-list-item-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Deck View Styles */
        .deck-view-section {
            margin-bottom: 2rem;
        }

        .deck-view-section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #667eea;
            color: #2c3e50;
        }

        .deck-view-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .deck-view-card {
            position: relative;
            aspect-ratio: 59/86;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .deck-view-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .deck-view-card-placeholder {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 0.7rem;
        }

        .deck-view-card-rarity {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: 700;
            line-height: 1.2;
        }

        .deck-view-card-code {
            position: absolute;
            bottom: 2px;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Hide code and rarity in deck view when toggle is off */
        .hide-card-details .deck-view-card-code,
        .hide-card-details .deck-view-card-rarity {
            display: none;
        }

        .deck-list-item-memo {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .deck-list-item-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: #495057;
        }

        @media (max-width: 768px) {
            .deck-cards-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .deck-list-panel {
                width: 100%;
                left: -100%;
            }

            .deck-list-panel.active {
                left: 0;
            }

            .deck-builder-panel {
                width: 100%;
                left: -100%;
            }

            .edit-panel {
                width: 100%;
                max-width: 100%;
            }

            .edit-panel-content {
                flex-direction: column;
            }

            .edit-panel-left {
                min-height: 300px;
                max-height: 40vh;
            }

            .edit-panel-left img {
                max-height: 35vh;
            }

            .edit-panel-right {
                flex: none;
            }

            body.deck-builder-open .header-section,
            body.deck-builder-open .container {
                margin-left: 0;
            }
        }

        /* Advanced filter button styles */
        .level-btn.active,
        .attribute-btn.active,
        .race-btn.active,
        .card-type-btn.active {
            background-color: #0d6efd !important;
            color: white !important;
            border-color: #0d6efd !important;
        }

        .level-btn:hover,
        .attribute-btn:hover,
        .race-btn:hover,
        .card-type-btn:hover {
            background-color: #0d6efd;
            color: white;
            border-color: #0d6efd;
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div class="loading-overlay hidden" id="loading-overlay">
        <div class="spinner-border text-light" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">読み込み中...</span>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-custom">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <i class="bi bi-layers-fill"></i>
                Card Manager
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link-custom" href="index.html">
                            <i class="bi bi-house-door-fill"></i>
                            ホーム
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link-custom" href="card_list.html">
                            <i class="bi bi-list-ul"></i>
                            カード管理
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link-custom active" href="card_gallery.html">
                            <i class="bi bi-grid-3x3-gap-fill"></i>
                            ギャラリー
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link-custom" href="battle_records.html">
                            <i class="bi bi-trophy-fill"></i>
                            対戦記録
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Header -->
    <div class="header-section">
        <div class="container text-center">
            <h1>
                <i class="bi bi-grid-3x3-gap-fill"></i> カードギャラリー
            </h1>
            <p class="header-subtitle">
                <i class="bi bi-collection-fill"></i> あなたのコレクションを美しく表示
            </p>
        </div>
    </div>

    <div class="container">
        <!-- List type selector tabs -->
        <ul class="nav nav-tabs mb-3" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="collection-tab" data-list-type="collection" type="button">
                    <i class="bi bi-collection"></i> 所持カード
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="wishlist-tab" data-list-type="wishlist" type="button">
                    <i class="bi bi-star"></i> ウィッシュリスト
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="bookmark-tab" data-list-type="bookmark" type="button">
                    <i class="bi bi-bookmark"></i> ブックマーク
                </button>
            </li>
        </ul>

        <!-- Stats bar -->
        <div class="stats-bar">
            <div class="row text-center">
                <div class="col-6 col-md-3">
                    <h4 class="mb-0 text-primary" id="total-cards">0</h4>
                    <small class="text-muted">総カード枚数</small>
                </div>
                <div class="col-6 col-md-3">
                    <h4 class="mb-0 text-success" id="unique-cards">0</h4>
                    <small class="text-muted">種類数</small>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <h4 class="mb-0 text-info" id="filtered-cards">0</h4>
                    <small class="text-muted">表示中</small>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <h4 class="mb-0 text-warning" id="current-page-info">0</h4>
                    <small class="text-muted">ページ</small>
                </div>
            </div>
        </div>

        <!-- Filter section -->
        <div class="filter-section">
            <div class="row g-2">
                <div class="col-md-3">
                    <input type="text" class="form-control" id="search-input" placeholder="カード名で検索...">
                </div>
                <div class="col-md-2">
                    <input type="text" class="form-control" id="code-search-input" placeholder="型番で検索...">
                </div>
                <div class="col-md-2">
                    <select class="form-select" id="rarity-filter">
                        <option value="">すべてのレアリティ</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <select class="form-select" id="tag-filter">
                        <option value="">すべてのタグ</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <button class="btn btn-outline-info w-100" type="button" data-bs-toggle="collapse" data-bs-target="#advanced-search">
                        <i class="bi bi-funnel"></i> 詳細検索
                    </button>
                </div>
                <div class="col-md-2">
                    <button class="btn btn-outline-secondary w-100" id="clear-filters">
                        <i class="bi bi-x-circle"></i> クリア
                    </button>
                </div>
            </div>
            <!-- Advanced Search (Collapsible) -->
            <div class="collapse mt-3" id="advanced-search">
                <div class="card card-body bg-light">
                    <div class="row g-3">
                        <!-- Level/Rank/Link -->
                        <div class="col-12">
                            <label class="form-label small fw-bold">レベル・ランク・リンク</label>
                            <div class="d-flex flex-wrap gap-1">
                                <button type="button" class="btn btn-sm btn-outline-secondary level-btn active" data-level="">
                                    すべて
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="0">0</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="1">1</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="2">2</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="3">3</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="4">4</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="5">5</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="6">6</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="7">7</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="8">8</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="9">9</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="10">10</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="11">11</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="12">12</button>
                                <button type="button" class="btn btn-sm btn-outline-primary level-btn" data-level="13">13</button>
                            </div>
                        </div>
                        <!-- Attribute -->
                        <div class="col-12">
                            <label class="form-label small fw-bold">属性</label>
                            <div class="d-flex flex-wrap gap-1">
                                <button type="button" class="btn btn-sm btn-outline-secondary attribute-btn active" data-attribute="">
                                    すべて
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="闇">闇</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="光">光</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="地">地</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="水">水</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="炎">炎</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="風">風</button>
                                <button type="button" class="btn btn-sm btn-outline-primary attribute-btn" data-attribute="神">神</button>
                            </div>
                        </div>
                        <!-- Card Type -->
                        <div class="col-12">
                            <div class="d-flex align-items-center justify-content-between mb-2">
                                <label class="form-label small fw-bold mb-0">カードタイプ</label>
                                <div class="btn-group btn-group-sm" role="group">
                                    <input type="radio" class="btn-check" name="card_type_mode" id="card-type-and" value="and" checked autocomplete="off">
                                    <label class="btn btn-outline-primary" for="card-type-and" style="font-size: 0.75rem; padding: 0.15rem 0.5rem;">
                                        AND
                                    </label>
                                    <input type="radio" class="btn-check" name="card_type_mode" id="card-type-or" value="or" autocomplete="off">
                                    <label class="btn btn-outline-success" for="card-type-or" style="font-size: 0.75rem; padding: 0.15rem 0.5rem;">
                                        OR
                                    </label>
                                </div>
                            </div>
                            <div class="d-flex flex-wrap gap-1">
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="通常">通常</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="効果">効果</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="融合">融合</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="シンクロ">シンクロ</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="エクシーズ">エクシーズ</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="リンク">リンク</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="ペンデュラム">ペンデュラム</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="儀式">儀式</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="チューナー">チューナー</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="魔法">魔法</button>
                                <button type="button" class="btn btn-sm btn-outline-primary card-type-btn" data-type="罠">罠</button>
                            </div>
                        </div>
                        <!-- Race -->
                        <div class="col-12">
                            <label class="form-label small fw-bold">種族</label>
                            <div class="d-flex flex-wrap gap-1">
                                <button type="button" class="btn btn-sm btn-outline-secondary race-btn active" data-race="">
                                    すべて
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="ドラゴン族">ドラゴン族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="戦士族">戦士族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="獣戦士族">獣戦士族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="魔法使い族">魔法使い族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="天使族">天使族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="悪魔族">悪魔族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="アンデット族">アンデット族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="機械族">機械族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="獣族">獣族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="鳥獣族">鳥獣族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="植物族">植物族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="昆虫族">昆虫族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="水族">水族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="岩石族">岩石族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="炎族">炎族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="雷族">雷族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="恐竜族">恐竜族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="魚族">魚族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="海竜族">海竜族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="爬虫類族">爬虫類族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="サイキック族">サイキック族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="幻竜族">幻竜族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="サイバース族">サイバース族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="幻神獣族">幻神獣族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="創造神族">創造神族</button>
                                <button type="button" class="btn btn-sm btn-outline-primary race-btn" data-race="幻想魔族">幻想魔族</button>
                            </div>
                        </div>
                        <!-- Attack -->
                        <div class="col-md-6">
                            <label class="form-label small fw-bold">攻撃力</label>
                            <input type="text" class="form-control form-control-sm" id="attack-filter">
                        </div>
                        <!-- Defense -->
                        <div class="col-md-6">
                            <label class="form-label small fw-bold">守備力</label>
                            <input type="text" class="form-control form-control-sm" id="defense-filter">
                        </div>
                    </div>
                </div>
            </div>
            <div class="row g-2 mt-2">
                <div class="col-md-12">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-unowned-cards" role="switch">
                        <label class="form-check-label" for="show-unowned-cards">
                            <i class="bi bi-eye"></i> 未所持カードを表示（全カードデータから）
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls bar -->
        <div class="controls-bar">
            <div class="view-controls">
                <!-- Display count -->
                <div class="input-group" style="width: auto;">
                    <label class="input-group-text" for="items-per-page">表示件数</label>
                    <select class="form-select" id="items-per-page" style="width: auto;">
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                        <option value="50" selected>50</option>
                        <option value="100">100</option>
                    </select>
                </div>

                <!-- Grid size selector -->
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn" data-size="small" title="小">
                        <i class="bi bi-square" style="font-size: 0.7rem;"></i> 小
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn active" data-size="medium" title="中">
                        <i class="bi bi-square" style="font-size: 0.9rem;"></i> 中
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn" data-size="large" title="大">
                        <i class="bi bi-square" style="font-size: 1.1rem;"></i> 大
                    </button>
                </div>

                <!-- Sort selector -->
                <div class="input-group" style="width: auto;">
                    <label class="input-group-text" for="sort-select">並び替え</label>
                    <select class="form-select" id="sort-select" style="width: auto;">
                        <option value="name-asc">名前 (昇順)</option>
                        <option value="name-desc">名前 (降順)</option>
                        <option value="code-asc">型番 (昇順)</option>
                        <option value="code-desc">型番 (降順)</option>
                        <option value="quantity-desc" selected>枚数 (多い順)</option>
                        <option value="quantity-asc">枚数 (少ない順)</option>
                        <option value="rarity-asc">レアリティ (昇順)</option>
                        <option value="rarity-desc">レアリティ (降順)</option>
                    </select>
                </div>

                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-warning btn-sm" id="deck-manager-btn">
                        <i class="bi bi-stack"></i> デッキ管理
                    </button>
                    <button class="btn btn-primary btn-sm" onclick="window.location.href='card_list.html'">
                        <i class="bi bi-arrow-left"></i> リスト表示に戻る
                    </button>
                </div>
            </div>
        </div>

        <!-- Pagination top -->
        <div class="pagination-controls" id="pagination-top"></div>

        <!-- Card grid -->
        <div class="card-grid size-medium" id="card-grid">
            <!-- Cards will be rendered here -->
        </div>

        <!-- Pagination bottom -->
        <div class="pagination-controls" id="pagination-bottom"></div>
    </div>

    <!-- Card Edit Side Panel -->
    <div class="edit-panel-overlay" id="editPanelOverlay"></div>
    <div class="edit-panel" id="editPanel">
        <div class="edit-panel-content">
            <!-- Left side: Card Image -->
            <div class="edit-panel-left">
                <img id="panelCardImage" src="" alt="Card Image">
                <!-- Illustration selector (only shown for cards with multiple illustrations) -->
                <div id="illustrationSelector" style="display: none; margin-top: 1rem;">
                    <button class="btn btn-sm btn-success w-100" id="changeIllustrationBtn">
                        <i class="bi bi-image"></i> イラスト違いを選択
                    </button>
                    <div id="illustrationOptions" style="display: none; margin-top: 0.5rem; max-height: 150px; overflow-y: auto;">
                        <!-- Illustration thumbnails will be added here -->
                    </div>
                </div>
            </div>

            <!-- Right side: Edit Form -->
            <div class="edit-panel-right">
                <div class="edit-panel-header">
                    <h3 id="panelCardName">カード編集</h3>
                    <button class="edit-panel-close" id="closePanelBtn">
                        <i class="bi bi-x"></i>
                    </button>
                </div>

                <form class="edit-panel-form">
                    <div class="mb-3">
                        <label for="panelQuantity" class="form-label">
                            <i class="bi bi-stack"></i> 枚数
                        </label>
                        <input type="number" class="form-control" id="panelQuantity" min="0">
                    </div>

                    <div class="mb-3">
                        <label for="panelTags" class="form-label">
                            <i class="bi bi-tags"></i> タグ（カンマ区切り）
                        </label>
                        <input type="text" class="form-control" id="panelTags" placeholder="デッキ1, お気に入り">
                    </div>

                    <div class="mb-3">
                        <label class="form-label">
                            <i class="bi bi-upc"></i> 型番
                        </label>
                        <p class="form-control-plaintext" id="panelCode">-</p>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">
                            <i class="bi bi-gem"></i> レアリティ
                        </label>
                        <p class="form-control-plaintext" id="panelRarity">-</p>
                    </div>

                    <div class="edit-panel-actions">
                        <button type="button" class="btn btn-danger" id="deletePanelCardBtn">
                            <i class="bi bi-trash"></i> 削除
                        </button>
                        <button type="button" class="btn btn-primary" id="savePanelCardBtn">
                            <i class="bi bi-save"></i> 保存
                        </button>
                    </div>

                    <!-- Deck usage section -->
                    <div id="deckUsageSection" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #dee2e6;">
                        <label class="form-label">
                            <i class="bi bi-collection"></i> デッキ使用状況
                        </label>
                        <div id="deckUsageList" style="font-size: 0.9rem; color: #495057;">
                            <!-- Deck usage will be displayed here -->
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Deck List Side Panel -->
    <div class="deck-list-panel" id="deckListPanel">
        <div class="deck-list-header">
            <h4><i class="bi bi-stack"></i> デッキ管理</h4>
            <button class="deck-list-close" id="closeDeckListBtn">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="deck-list-content">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h6 class="mb-0">デッキ一覧</h6>
                <button class="btn btn-primary btn-sm" id="create-new-deck-btn">
                    <i class="bi bi-plus-circle"></i> 新規デッキ作成
                </button>
            </div>
            <div id="deck-list-container">
                <!-- Deck list will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Deck Builder Side Panel -->
    <div class="deck-builder-panel" id="deckBuilderPanel">
        <div class="deck-builder-header">
            <h4 id="deckBuilderTitle">デッキ編集</h4>
            <div style="display: flex; gap: 0.5rem;">
                <button class="btn btn-sm btn-outline-secondary" id="toggleCardDetailsBtn" title="型番・レアリティの表示/非表示">
                    <i class="bi bi-info-circle"></i>
                </button>
                <button class="deck-builder-close" id="closeDeckBuilderBtn">
                    <i class="bi bi-x"></i>
                </button>
            </div>
        </div>
        <div class="deck-builder-content">
            <!-- Deck Info -->
            <div class="deck-info-section">
                <div class="mb-2">
                    <label class="form-label small fw-bold">デッキ名</label>
                    <input type="text" class="form-control form-control-sm" id="deckName" placeholder="デッキ名を入力">
                </div>
                <div class="mb-3">
                    <label class="form-label small fw-bold">メモ</label>
                    <textarea class="form-control form-control-sm" id="deckMemo" rows="2" placeholder="メモを入力"></textarea>
                </div>
            </div>

            <!-- Deck Cards -->
            <div class="deck-cards-section">
                <!-- Main Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">メインデッキ (<span id="mainDeckCount">0</span>/1~60)</h6>
                    </div>
                    <div class="deck-drop-zone" id="mainDeckDropZone" data-deck-type="main">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">メインデッキ (40~60枚)</p>
                        </div>
                        <div id="mainDeckCardsList"></div>
                    </div>
                </div>

                <!-- Extra Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">エクストラデッキ (<span id="extraDeckCount">0</span>/0~15)</h6>
                    </div>
                    <div class="deck-drop-zone" id="extraDeckDropZone" data-deck-type="extra">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">エクストラデッキ (0~15枚)</p>
                        </div>
                        <div id="extraDeckCardsList"></div>
                    </div>
                </div>

                <!-- Side Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">サイドデッキ (<span id="sideDeckCount">0</span>/0~15)</h6>
                    </div>
                    <div class="deck-drop-zone" id="sideDeckDropZone" data-deck-type="side">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">サイドデッキ (0~15枚)</p>
                        </div>
                        <div id="sideDeckCardsList"></div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="deck-builder-actions">
                <button class="btn btn-success w-100" id="saveDeckBtn">
                    <i class="bi bi-save"></i> デッキを保存
                </button>
                <button class="btn btn-outline-danger w-100 mt-2" id="deleteDeckBtn">
                    <i class="bi bi-trash"></i> デッキを削除
                </button>
            </div>
        </div>
    </div>

    <!-- Deck View Modal -->
    <div class="modal fade" id="deckViewModal" tabindex="-1">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-eye"></i> <span id="viewDeckName">デッキ閲覧</span>
                    </h5>
                    <div class="d-flex gap-2 align-items-center">
                        <button class="btn btn-sm btn-outline-secondary" id="toggleDeckViewDetailsBtn" title="型番・レアリティの表示/非表示">
                            <i class="bi bi-info-circle"></i>
                        </button>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                </div>
                <div class="modal-body" style="background: #f8f9fa;">
                    <div class="mb-3 d-flex justify-content-end gap-2">
                        <button class="btn btn-primary" id="exportDeckImageBtn">
                            <i class="bi bi-download"></i> 画像として保存
                        </button>
                    </div>
                    <div id="deckViewContent" style="background: white; padding: 2rem; border-radius: 8px;">
                        <!-- Deck content will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { getFirestore, collection, getDocs, doc, updateDoc, deleteDoc, addDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAOYKalLUb2hbghrjQUS8AWzxpLExBT7aU",
            authDomain: "ygoh-9bcf6.firebaseapp.com",
            projectId: "ygoh-9bcf6",
            storageBucket: "ygoh-9bcf6.firebasestorage.app",
            messagingSenderId: "515041224138",
            appId: "1:515041224138:web:8de47b38ed9cc1bb8afd37",
            measurementId: "G-ZGSRE8MHZ2"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // State
        let collectionCards = [];
        let wishlistCards = [];
        let bookmarkCards = [];
        let allCards = [];
        let filteredCards = [];
        let cardDetailsMap = new Map();
        let cardReadingMap = new Map(); // Map for hiragana -> card names
        let currentUser = null;
        let currentPage = 1;
        let itemsPerPage = 50;
        let currentGridSize = 'medium';
        let currentSort = 'quantity-desc';
        let currentListType = 'collection'; // 'collection', 'wishlist', or 'bookmark'
        let currentEditingCard = null;
        let currentRenderingId = 0; // To prevent duplicate images when rapidly changing pages

        // Advanced filter state
        let selectedLevel = '';
        let selectedAttribute = '';
        let selectedRace = '';
        let selectedCardTypes = []; // Array for multiple card types
        let cardTypeSearchMode = 'and'; // 'and' or 'or'

        // Deck system state
        let decks = []; // All user's decks
        let currentDeck = null; // Currently editing deck
        const deckListPanel = document.getElementById('deckListPanel');
        let draggedCard = null; // Card being dragged from gallery
        let draggedDeckCard = null; // Deck card being dragged (for moving between decks or removing)

        // Load card reading data
        const loadCardData = async () => {
            try {
                const response = await fetch('yugioh_cards_master.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');

                // Parse CSV and build card details map
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(',');
                    const cardName = values[1]?.replace(/"/g, '');
                    const cardId = values[0]?.replace(/"/g, '');
                    const cardReading = values[2]?.replace(/"/g, '');

                    if (cardName && cardId) {
                        cardDetailsMap.set(cardName, {
                            cardId: cardId,
                            reading: cardReading,
                            cardType: values[3]?.replace(/"/g, ''),
                            level: values[4]?.replace(/"/g, ''),
                            attribute: values[5]?.replace(/"/g, ''),
                            race: values[6]?.replace(/"/g, ''),
                            attack: values[7]?.replace(/"/g, ''),
                            defense: values[8]?.replace(/"/g, ''),
                            cardText: values[9]?.replace(/"/g, '')
                        });

                        // Build reading map for hiragana search
                        if (cardReading) {
                            const readingKey = cardReading.toLowerCase();

                            // Store multiple cards with same reading
                            if (!cardReadingMap.has(readingKey)) {
                                cardReadingMap.set(readingKey, []);
                            }
                            cardReadingMap.get(readingKey).push(cardName);

                            // Also store hiragana version of the reading if it's in katakana
                            const hiraganaReading = readingKey.replace(/[\u30A1-\u30F6]/g, function(match) {
                                const code = match.charCodeAt(0) - 0x60;
                                return String.fromCharCode(code);
                            });

                            if (hiraganaReading !== readingKey) {
                                if (!cardReadingMap.has(hiraganaReading)) {
                                    cardReadingMap.set(hiraganaReading, []);
                                }
                                cardReadingMap.get(hiraganaReading).push(cardName);
                            }
                        }
                    }
                }

                console.log(`Loaded ${cardReadingMap.size} card readings and ${cardDetailsMap.size} card details from CSV`);
            } catch (error) {
                console.error('Error loading card data:', error);
            }
        };

        // Get card image URL (with cache support)
        const getCardImageUrl = async (cardName, ciid = '1') => {
            const details = cardDetailsMap.get(cardName);
            if (!details?.cardId) {
                return null;
            }

            const cardId = details.cardId;
            const cacheKey = `${cardId}_${ciid}`; // Use cardId_ciid as cache key

            try {
                // Check cache first
                const cachedImage = await imageCacheManager.getImage(cacheKey);
                if (cachedImage) {
                    console.log(`Using cached image for: ${cardName} (ID: ${cardId}, ciid: ${ciid})`);
                    return cachedImage;
                }

                // Cache miss - fetch from proxy and cache it
                console.log(`Fetching image for: ${cardName} (ID: ${cardId}, ciid: ${ciid})`);
                const imageData = await imageCacheManager.fetchAndCache(cacheKey, cardId, ciid);
                return imageData;
            } catch (error) {
                console.error(`Error loading image for ${cardName}:`, error);
                // Fallback to direct URL (will likely fail due to CORS, but worth trying)
                return `https://www.db.yugioh-card.com/yugiohdb/card_image.action?cid=${cardId}&request_locale=ja`;
            }
        };

        // Load user's card collection and wishlist
        const loadAllData = async (userId) => {
            showLoading(true);
            try {
                // Load collection cards from subcollection: users/{userId}/cards
                const collectionRef = collection(db, 'users', userId, 'cards');
                const collectionSnapshot = await getDocs(collectionRef);
                collectionCards = collectionSnapshot.docs.map(doc => ({
                    id: doc.id,
                    data: doc.data()
                }));

                // Load wishlist cards from subcollection: users/{userId}/wishlist
                const wishlistRef = collection(db, 'users', userId, 'wishlist');
                const wishlistSnapshot = await getDocs(wishlistRef);
                wishlistCards = wishlistSnapshot.docs.map(doc => ({
                    id: doc.id,
                    data: doc.data()
                }));

                // Load bookmark cards from subcollection: users/{userId}/bookmarks
                const bookmarkRef = collection(db, 'users', userId, 'bookmarks');
                const bookmarkSnapshot = await getDocs(bookmarkRef);
                bookmarkCards = bookmarkSnapshot.docs.map(doc => ({
                    id: doc.id,
                    data: doc.data()
                }));

                // Load decks to calculate card usage
                await loadDecks();

                // Set initial data based on current list type
                switchListType(currentListType);
            } catch (error) {
                console.error('Error loading data:', error);
                alert('カードの読み込みに失敗しました。');
            } finally {
                showLoading(false);
            }
        };

        // Switch between collection, wishlist, and bookmark
        const switchListType = (listType) => {
            currentListType = listType;
            allCards = listType === 'collection' ? collectionCards :
                       listType === 'wishlist' ? wishlistCards :
                       bookmarkCards;

            // Save to localStorage
            localStorage.setItem('galleryListType', listType);

            // Update tab active state
            document.querySelectorAll('.nav-link').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`${listType}-tab`).classList.add('active');

            // Reset to page 1 when switching
            currentPage = 1;

            applyFilters();
            updateStats();
            renderCards();
            populateFilterOptions();
        };

        // Show/hide loading overlay
        const showLoading = (show) => {
            const overlay = document.getElementById('loading-overlay');
            if (show) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        };

        // Normalize text for search (convert katakana to hiragana, lowercase)
        const normalizeForSearch = (text) => {
            if (!text) return '';

            // Convert to lowercase
            text = text.toLowerCase();

            // Convert katakana to hiragana
            text = text.replace(/[ァ-ヶ]/g, (match) => {
                const code = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(code);
            });

            // Remove middle dots (・) for more flexible search
            text = text.replace(/・/g, '');

            return text;
        };

        // Apply filters
        const applyFilters = () => {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const codeSearchTerm = document.getElementById('code-search-input').value.toLowerCase();
            const rarityFilter = document.getElementById('rarity-filter').value;
            const tagFilter = document.getElementById('tag-filter').value;
            const showUnowned = document.getElementById('show-unowned-cards').checked;

            // Advanced filters
            const levelFilter = selectedLevel;
            const attributeFilter = selectedAttribute;
            const cardTypeFilters = selectedCardTypes; // Array of selected card types
            const raceFilter = selectedRace;
            const attackFilter = document.getElementById('attack-filter') ? document.getElementById('attack-filter').value.trim() : '';
            const defenseFilter = document.getElementById('defense-filter') ? document.getElementById('defense-filter').value.trim() : '';

            // Debug logging
            console.log('Filter values:', {
                searchTerm,
                rarityFilter,
                tagFilter,
                levelFilter,
                attributeFilter,
                cardTypeFilters,
                raceFilter,
                attackFilter,
                defenseFilter,
                allCardsCount: allCards.length
            });

            // Debug: Show first card's data structure
            if (allCards.length > 0) {
                console.log('First card data sample:', allCards[0].data);
                console.log('Available fields:', Object.keys(allCards[0].data));
                if (allCards[0].data.linkedDetails) {
                    console.log('LinkedDetails:', allCards[0].data.linkedDetails);
                }
            }

            // Get possible card names from hiragana reading
            let possibleCardNames = [];
            if (searchTerm) {
                // Check if the search term matches any reading in our map
                if (cardReadingMap.has(searchTerm)) {
                    possibleCardNames = cardReadingMap.get(searchTerm);
                }

                // Also check for partial matches in readings
                for (const [reading, cards] of cardReadingMap) {
                    if (reading.includes(searchTerm)) {
                        possibleCardNames.push(...cards);
                    }
                }
            }

            // Normalize search term for card name matching
            const normalizedSearchTerm = normalizeForSearch(searchTerm);

            // Filter owned cards
            filteredCards = allCards.filter(card => {
                const cardName = card.data['名前'] || '';
                const cardCode = card.data['型番'] || '';

                // Check if matches name search
                let matchesNameSearch = !searchTerm;
                if (searchTerm) {
                    // Direct name match (normalized)
                    if (normalizeForSearch(cardName).includes(normalizedSearchTerm)) {
                        matchesNameSearch = true;
                    }
                    // Hiragana reading match
                    else if (possibleCardNames.includes(cardName)) {
                        matchesNameSearch = true;
                    }
                }

                // Check if matches code search
                let matchesCodeSearch = !codeSearchTerm;
                if (codeSearchTerm) {
                    if (cardCode.toLowerCase().includes(codeSearchTerm)) {
                        matchesCodeSearch = true;
                    }
                }

                const matchesRarity = !rarityFilter || card.data['レアリティ'] === rarityFilter;
                const matchesTag = !tagFilter || (card.data.tags && card.data.tags.includes(tagFilter));

                // Advanced filters - use linkedDetails for card details (English field names)
                const details = card.data.linkedDetails || {};
                const matchesLevel = !levelFilter || (details.level && details.level.toString() === levelFilter);
                const matchesAttribute = !attributeFilter || details.attribute === attributeFilter;

                // Card type filter with AND/OR logic
                let matchesCardType = true;
                if (cardTypeFilters.length > 0) {
                    const cardType = details.cardType || '';
                    if (cardTypeSearchMode === 'and') {
                        // AND: All selected types must be present
                        matchesCardType = cardTypeFilters.every(type => cardType.includes(type));
                    } else {
                        // OR: At least one selected type must be present
                        matchesCardType = cardTypeFilters.some(type => cardType.includes(type));
                    }
                }

                const matchesRace = !raceFilter || details.race === raceFilter;
                const matchesAttack = !attackFilter || (details.attack && details.attack.toString() === attackFilter);
                const matchesDefense = !defenseFilter || (details.defense && details.defense.toString() === defenseFilter);

                return matchesNameSearch && matchesCodeSearch && matchesRarity && matchesTag && matchesLevel && matchesAttribute && matchesCardType && matchesRace && matchesAttack && matchesDefense;
            });

            console.log('Filtered cards count:', filteredCards.length);

            // Add unowned cards if checkbox is checked
            if (showUnowned) {
                // Get owned card names
                const ownedCardNames = new Set(allCards.map(card => card.data['名前']));

                // Create unowned cards from cardDetailsMap
                const unownedCards = [];
                for (const [cardName, details] of cardDetailsMap) {
                    if (!ownedCardNames.has(cardName)) {
                        // Apply filters to unowned cards too
                        const cardCode = details.cardId || '';

                        // Check if matches name search
                        let matchesNameSearch = !searchTerm;
                        if (searchTerm) {
                            if (normalizeForSearch(cardName).includes(normalizedSearchTerm)) {
                                matchesNameSearch = true;
                            } else if (possibleCardNames.includes(cardName)) {
                                matchesNameSearch = true;
                            }
                        }

                        // Check if matches code search
                        let matchesCodeSearch = !codeSearchTerm;
                        if (codeSearchTerm) {
                            if (cardCode.toLowerCase().includes(codeSearchTerm)) {
                                matchesCodeSearch = true;
                            }
                        }

                        // Note: unowned cards don't have rarity or tags, so skip those filters
                        if (matchesNameSearch && matchesCodeSearch && !rarityFilter && !tagFilter) {
                            unownedCards.push({
                                id: 'unowned-' + details.cardId,
                                data: {
                                    '名前': cardName,
                                    '型番': details.cardId || '',
                                    'レアリティ': '-',
                                    '枚数': 0,
                                    'tags': [],
                                    'unowned': true,
                                    'linkedDetails': details
                                },
                                unowned: true
                            });
                        }
                    }
                }

                // Add unowned cards to filtered results
                filteredCards = [...filteredCards, ...unownedCards];
            }

            sortCards();
            currentPage = 1;
        };

        // Sort cards
        const sortCards = () => {
            const [field, direction] = currentSort.split('-');

            filteredCards.sort((a, b) => {
                let valA, valB;

                switch (field) {
                    case 'name':
                        valA = a.data['名前'] || '';
                        valB = b.data['名前'] || '';
                        break;
                    case 'code':
                        valA = a.data['型番'] || '';
                        valB = b.data['型番'] || '';
                        break;
                    case 'quantity':
                        valA = parseInt(a.data['枚数']) || 0;
                        valB = parseInt(b.data['枚数']) || 0;
                        break;
                    case 'rarity':
                        valA = a.data['レアリティ'] || '';
                        valB = b.data['レアリティ'] || '';
                        break;
                    default:
                        return 0;
                }

                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (direction === 'asc') {
                    return valA > valB ? 1 : valA < valB ? -1 : 0;
                } else {
                    return valA < valB ? 1 : valA > valB ? -1 : 0;
                }
            });
        };

        // Handle drag start for cards
        window.handleDragStart = (event, index) => {
            const startIndex = (currentPage - 1) * itemsPerPage;
            const cardIndex = startIndex + index;
            draggedCard = filteredCards[cardIndex];
            event.dataTransfer.effectAllowed = 'copy';
            event.target.classList.add('dragging');
        };

        // Render cards (with async image loading)
        const renderCards = async () => {
            // Increment rendering ID to invalidate previous async operations
            currentRenderingId++;
            const thisRenderingId = currentRenderingId;

            const grid = document.getElementById('card-grid');
            grid.className = `card-grid size-${currentGridSize}`;

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageCards = filteredCards.slice(startIndex, endIndex);

            if (pageCards.length === 0) {
                grid.innerHTML = `
                    <div class="text-center py-5 w-100">
                        <i class="bi bi-inbox" style="font-size: 4rem; color: #ccc;"></i>
                        <p class="text-muted mt-3">該当するカードはありません。</p>
                    </div>
                `;
            } else {
                // First render with placeholders
                grid.innerHTML = pageCards.map((card, index) => {
                    const tags = (card.data.tags || []).map(tag =>
                        `<span class="badge bg-secondary">${escapeHtml(tag)}</span>`
                    ).join(' ');

                    const isUnowned = card.unowned || card.data.unowned;
                    const unownedClass = isUnowned ? ' unowned' : '';
                    const unownedBadge = isUnowned ? '<span class="unowned-badge">未所持</span>' : '';

                    // Calculate stock display with deck usage
                    let stockBadge = '';
                    if (!isUnowned) {
                        const totalStock = card.data['枚数'] || 0;

                        if (currentListType === 'wishlist') {
                            // For wishlist, show only "必要数" without deck usage
                            stockBadge = `<span class="stock-badge">必要数 ${totalStock}枚</span>`;
                        } else {
                            // For collection, show stock with deck usage
                            const { totalUsed } = getCardUsageInDecks(card.id);
                            const availableStock = totalStock - totalUsed;

                            if (totalUsed > 0) {
                                stockBadge = `<span class="stock-badge">在庫 ${availableStock}(${totalStock})枚</span>`;
                            } else {
                                stockBadge = `<span class="stock-badge">在庫 ${totalStock}枚</span>`;
                            }
                        }
                    }

                    const decodedName = decodeHtmlEntities(card.data['名前']);
                    // Allow dragging for both owned and unowned cards, but only owned cards can open edit modal
                    const onclickAttr = isUnowned ? '' : `onclick="openCardEditModal('${card.id}')"`;
                    const draggableAttr = `draggable="true" ondragstart="handleDragStart(event, ${index})" class="draggable"`;

                    return `
                        <div class="card-item${unownedClass}" ${onclickAttr} ${draggableAttr} data-card-index="${index}" data-card-id="${card.id}">
                            <div class="card-image-container" id="card-img-container-${index}" data-rendering-id="${thisRenderingId}">
                                ${stockBadge}
                                ${unownedBadge}
                                <i class="bi bi-card-image card-image-placeholder"></i>
                            </div>
                            <div class="card-info">
                                <div class="card-name">${escapeHtml(decodedName)}</div>
                                <div class="card-code">${escapeHtml(card.data['型番'])}</div>
                                <div class="card-rarity">
                                    <span class="badge bg-info">${escapeHtml(card.data['レアリティ'])}</span>
                                </div>
                                <div class="card-tags">
                                    ${tags || '<span class="text-muted" style="font-size: 0.7rem;">タグなし</span>'}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // Then load images asynchronously
                pageCards.forEach(async (card, index) => {
                    const loadCardImage = async () => {
                        const container = document.getElementById(`card-img-container-${index}`);
                        if (!container) return;

                        try {
                            // Decode HTML entities in card name before fetching image
                            const decodedCardName = decodeHtmlEntities(card.data['名前']);
                            const ciid = card.data.selectedCiid || '1';  // Use saved ciid if available
                            const imageUrl = await getCardImageUrl(decodedCardName, ciid);

                            // Check if this rendering is still valid (page hasn't changed)
                            if (parseInt(container.dataset.renderingId) !== thisRenderingId) {
                                return; // Skip adding image if page has changed
                            }

                            if (imageUrl) {
                                // Create image element
                                const img = document.createElement('img');
                                img.src = imageUrl;
                                img.alt = decodedCardName;
                                img.loading = 'lazy';

                                // Handle image error
                                img.onerror = function() {
                                    // Save parent reference before clearing
                                    const parent = this.parentElement;
                                    if (!parent) return;

                                    // Keep stock badge and show placeholder with reload button
                                    const stockBadge = parent.querySelector('.stock-badge');
                                    const unownedBadge = parent.querySelector('.unowned-badge');
                                    parent.innerHTML = '';
                                    if (stockBadge) {
                                        parent.appendChild(stockBadge);
                                    }
                                    if (unownedBadge) {
                                        parent.appendChild(unownedBadge);
                                    }
                                    const placeholder = document.createElement('i');
                                    placeholder.className = 'bi bi-card-image card-image-placeholder';
                                    parent.appendChild(placeholder);

                                    // Add reload button
                                    const reloadBtn = document.createElement('button');
                                    reloadBtn.className = 'card-image-reload';
                                    reloadBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>再読み込み';
                                    reloadBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        reloadBtn.remove();
                                        loadCardImage();
                                    };
                                    parent.appendChild(reloadBtn);
                                };

                                // Clear placeholder and add image (keep stock badge)
                                const stockBadge = container.querySelector('.stock-badge');
                                const unownedBadge = container.querySelector('.unowned-badge');
                                const placeholder = container.querySelector('.card-image-placeholder');
                                const reloadBtn = container.querySelector('.card-image-reload');
                                if (placeholder) {
                                    placeholder.remove();
                                }
                                if (reloadBtn) {
                                    reloadBtn.remove();
                                }
                                container.appendChild(img);
                            } else {
                                // No image URL - show reload button
                                const existingReloadBtn = container.querySelector('.card-image-reload');
                                if (!existingReloadBtn) {
                                    const reloadBtn = document.createElement('button');
                                    reloadBtn.className = 'card-image-reload';
                                    reloadBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>再読み込み';
                                    reloadBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        reloadBtn.remove();
                                        loadCardImage();
                                    };
                                    container.appendChild(reloadBtn);
                                }
                            }
                        } catch (error) {
                            console.error(`Failed to load image for ${card.data['名前']}:`, error);

                            // Show reload button on error
                            const container = document.getElementById(`card-img-container-${index}`);
                            if (container && parseInt(container.dataset.renderingId) === thisRenderingId) {
                                const existingReloadBtn = container.querySelector('.card-image-reload');
                                if (!existingReloadBtn) {
                                    const reloadBtn = document.createElement('button');
                                    reloadBtn.className = 'card-image-reload';
                                    reloadBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>再読み込み';
                                    reloadBtn.onclick = (e) => {
                                        e.stopPropagation();
                                        reloadBtn.remove();
                                        loadCardImage();
                                    };
                                    container.appendChild(reloadBtn);
                                }
                            }
                        }
                    };

                    loadCardImage();
                });
            }

            updatePagination();
            updateStats();
        };

        // Update pagination
        const updatePagination = () => {
            const totalPages = Math.ceil(filteredCards.length / itemsPerPage);
            const paginationHtml = `
                <button class="btn btn-outline-primary btn-sm" ${currentPage <= 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">
                    <i class="bi bi-chevron-left"></i> 前へ
                </button>
                <span class="mx-3">
                    <strong>${currentPage}</strong> / ${totalPages} ページ
                </span>
                <button class="btn btn-outline-primary btn-sm" ${currentPage >= totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">
                    次へ <i class="bi bi-chevron-right"></i>
                </button>
            `;

            document.getElementById('pagination-top').innerHTML = paginationHtml;
            document.getElementById('pagination-bottom').innerHTML = paginationHtml;
        };

        // Update stats
        const updateStats = () => {
            const totalQuantity = allCards.reduce((sum, card) => sum + (parseInt(card.data['枚数']) || 0), 0);
            const uniqueCount = allCards.length;
            const filteredCount = filteredCards.length;
            const totalPages = Math.ceil(filteredCards.length / itemsPerPage);

            document.getElementById('total-cards').textContent = totalQuantity;
            document.getElementById('unique-cards').textContent = uniqueCount;
            document.getElementById('filtered-cards').textContent = filteredCount;
            document.getElementById('current-page-info').textContent = `${currentPage}/${totalPages}`;
        };

        // Populate filter options
        const populateFilterOptions = () => {
            // Rarities
            const rarities = [...new Set(allCards.map(card => card.data['レアリティ']).filter(Boolean))].sort();
            const raritySelect = document.getElementById('rarity-filter');
            raritySelect.innerHTML = '<option value="">すべてのレアリティ</option>' +
                rarities.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');

            // Tags
            const tags = [...new Set(allCards.flatMap(card => card.data.tags || []))].sort();
            const tagSelect = document.getElementById('tag-filter');
            tagSelect.innerHTML = '<option value="">すべてのタグ</option>' +
                tags.map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join('');
        };

        // Utility functions
        const decodeHtmlEntities = (str) => {
            if (str == null) return '';
            const textarea = document.createElement('textarea');
            textarea.innerHTML = str;
            return textarea.value;
        };

        const escapeHtml = (str) => {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        };

        // Global functions
        window.changePage = (page) => {
            currentPage = page;
            renderCards();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        window.openCardEditModal = async (cardId) => {
            // Don't open edit modal if deck builder is active
            if (currentDeck) return;

            // Find the card in current list
            const card = allCards.find(c => c.id === cardId);
            if (!card) return;

            currentEditingCard = card;

            // Populate panel with card data immediately (synchronous)
            const decodedName = decodeHtmlEntities(card.data['名前']);
            document.getElementById('panelCardName').textContent = decodedName;
            document.getElementById('panelQuantity').value = card.data['枚数'] || 0;
            document.getElementById('panelTags').value = (card.data.tags || []).join(', ');
            document.getElementById('panelCode').textContent = card.data['型番'] || '-';
            document.getElementById('panelRarity').textContent = card.data['レアリティ'] || '-';

            // Display deck usage
            const { usageMap, totalUsed } = getCardUsageInDecks(cardId);
            const deckUsageSection = document.getElementById('deckUsageSection');
            const deckUsageList = document.getElementById('deckUsageList');

            if (totalUsed > 0) {
                let usageHTML = '';
                for (const [deckName, count] of Object.entries(usageMap)) {
                    usageHTML += `<div style="margin-bottom: 0.3rem;">・${deckName}: ${count}枚</div>`;
                }
                deckUsageList.innerHTML = usageHTML;
                deckUsageSection.style.display = 'block';
            } else {
                deckUsageSection.style.display = 'none';
            }

            // Open panel immediately
            document.getElementById('editPanelOverlay').classList.add('show');
            document.getElementById('editPanel').classList.add('show');

            // Hide illustration selector initially
            document.getElementById('illustrationSelector').style.display = 'none';

            // Load card image and illustrations asynchronously (don't block panel opening)
            const details = cardDetailsMap.get(decodedName);
            let currentCiid = card.data.selectedCiid || '1';  // Use saved ciid if available

            // Load image first (fast)
            const panelImage = document.getElementById('panelCardImage');
            console.log(`Loading initial card image for: ${decodedName}, ciid: ${currentCiid}`);
            getCardImageUrl(decodedName, currentCiid).then(imageUrl => {
                console.log('Initial image URL:', imageUrl);
                if (imageUrl) {
                    panelImage.src = imageUrl;
                    panelImage.style.display = 'block';
                    panelImage.dataset.currentCiid = currentCiid;
                    console.log('Panel image set to:', panelImage.src, 'with ciid:', currentCiid);
                } else {
                    console.log('No image URL found, hiding panel image');
                    panelImage.style.display = 'none';
                }
            });

            // Fetch illustrations in background (slower)
            if (details?.cardId) {
                console.log(`Fetching illustrations for card: ${decodedName}, cardId: ${details.cardId}`);

                const proxyUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                    ? 'http://localhost:3000'
                    : 'https://ygoh-list.onrender.com';

                fetch(`${proxyUrl}/card-detail?cid=${details.cardId}`)
                    .then(response => response.json())
                    .then(cardDetail => {
                        console.log('Card detail response:', cardDetail);
                        console.log('Illustrations:', cardDetail.illustrations);

                        if (cardDetail.illustrations && cardDetail.illustrations.length > 1) {
                            const illustrations = cardDetail.illustrations;
                            console.log(`Found ${illustrations.length} illustrations, showing selector`);

                            // Show illustration selector
                            document.getElementById('illustrationSelector').style.display = 'block';

                            // Setup illustration selector
                            setupIllustrationSelector(illustrations, currentCiid, panelImage);
                        } else {
                            console.log('Single illustration card, keeping selector hidden');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching card illustrations:', error);
                    });
            }
        };

        // Helper function to setup illustration selector
        const setupIllustrationSelector = (illustrations, currentCiid, panelImage) => {
            const changeBtn = document.getElementById('changeIllustrationBtn');
            const optionsDiv = document.getElementById('illustrationOptions');

            // Clear previous options
            optionsDiv.innerHTML = '';

            // Toggle illustration options
            changeBtn.onclick = () => {
                console.log('=== CHANGE ILLUSTRATION BUTTON CLICKED ===');
                const isVisible = optionsDiv.style.display !== 'none';
                console.log('Options currently visible:', isVisible);
                optionsDiv.style.display = isVisible ? 'none' : 'flex';

                // Load thumbnails if first time opening
                if (!isVisible && optionsDiv.children.length === 0) {
                    console.log('Loading illustration thumbnails...');
                    illustrations.forEach((ill, index) => {
                        const img = document.createElement('img');
                        img.src = ill.imageUrl;
                        img.className = 'illustration-option';
                        if (ill.ciid === currentCiid) {
                            img.classList.add('active');
                        }
                        img.title = `イラスト ${ill.ciid}`;
                        img.onclick = async () => {
                            console.log('=== ILLUSTRATION CHANGE CLICKED ===');
                            console.log('Selected illustration:', ill);
                            console.log('Previous ciid:', panelImage.dataset.currentCiid);
                            console.log('New ciid:', ill.ciid);
                            console.log('New imageUrl:', ill.imageUrl);

                            // Update main panel image
                            panelImage.src = ill.imageUrl;
                            panelImage.dataset.currentCiid = ill.ciid;
                            console.log('Panel image updated. Current src:', panelImage.src);

                            // Update gallery card image
                            if (currentEditingCard) {
                                const galleryCardItem = document.querySelector(`.card-item[data-card-id="${currentEditingCard.id}"]`);
                                const galleryCardImg = galleryCardItem?.querySelector('img');
                                if (galleryCardImg) {
                                    console.log('Updating gallery card image for card ID:', currentEditingCard.id);
                                    galleryCardImg.src = ill.imageUrl;
                                    console.log('Gallery card image updated to:', ill.imageUrl);
                                } else {
                                    console.warn('Gallery card image element not found for card ID:', currentEditingCard.id);
                                    console.warn('Gallery card item:', galleryCardItem);
                                }

                                // Store ciid in card data and save to Firestore
                                currentEditingCard.selectedCiid = ill.ciid;
                                currentEditingCard.data.selectedCiid = ill.ciid;
                                console.log('Stored ciid in card data:', ill.ciid);

                                // Save to Firestore
                                if (currentUser) {
                                    const cardRef = doc(db, 'users', currentUser.uid, 'cards', currentEditingCard.id);
                                    updateDoc(cardRef, {
                                        selectedCiid: ill.ciid
                                    }).then(() => {
                                        console.log('Selected ciid saved to Firestore');
                                    }).catch(error => {
                                        console.error('Error saving selectedCiid to Firestore:', error);
                                    });
                                }
                            }

                            // Update active state
                            optionsDiv.querySelectorAll('.illustration-option').forEach(opt => {
                                opt.classList.remove('active');
                            });
                            img.classList.add('active');

                            // Close options
                            optionsDiv.style.display = 'none';
                            console.log('Illustration options closed');
                        };
                        optionsDiv.appendChild(img);
                    });
                }
            };
        };

        // Close panel function
        const closeEditPanel = () => {
            document.getElementById('editPanelOverlay').classList.remove('show');
            document.getElementById('editPanel').classList.remove('show');

            // Clear illustration options
            const optionsDiv = document.getElementById('illustrationOptions');
            optionsDiv.innerHTML = '';
            optionsDiv.style.display = 'none';
            document.getElementById('illustrationSelector').style.display = 'none';
        };

        // ==================== BOOKMARK FUNCTIONS ====================

        /**
         * Add card to bookmarks
         */
        const addToBookmarks = async (cardData) => {
            if (!currentUser) return;

            try {
                const bookmarkRef = doc(db, 'users', currentUser.uid, 'bookmarks', cardData.id);
                await setDoc(bookmarkRef, {
                    名前: cardData.data['名前'],
                    型番: cardData.data['型番'],
                    レアリティ: cardData.data['レアリティ'],
                    枚数: cardData.data['枚数'] || 1,
                    tags: cardData.data.tags || [],
                    selectedCiid: cardData.data.selectedCiid,
                    addedAt: new Date().toISOString()
                });

                console.log('Added to bookmarks:', cardData.id);

                // Reload bookmarks
                await loadAllData(currentUser.uid);

                alert('ブックマークに追加しました');
            } catch (error) {
                console.error('Error adding to bookmarks:', error);
                alert('ブックマークの追加に失敗しました');
            }
        };

        /**
         * Remove card from bookmarks
         */
        const removeFromBookmarks = async (cardId) => {
            if (!currentUser) return;

            try {
                const bookmarkRef = doc(db, 'users', currentUser.uid, 'bookmarks', cardId);
                await deleteDoc(bookmarkRef);

                console.log('Removed from bookmarks:', cardId);

                // Reload bookmarks
                await loadAllData(currentUser.uid);

                alert('ブックマークから削除しました');
            } catch (error) {
                console.error('Error removing from bookmarks:', error);
                alert('ブックマークの削除に失敗しました');
            }
        };

        /**
         * Check if card is bookmarked
         */
        const isBookmarked = (cardId) => {
            return bookmarkCards.some(c => c.id === cardId);
        };

        /**
         * Setup context menu for cards
         */
        const setupContextMenu = () => {
            const contextMenu = document.getElementById('contextMenu');
            const cardGrid = document.getElementById('card-grid');

            // Show context menu
            const showContextMenu = (x, y, items) => {
                contextMenu.innerHTML = items.map(item =>
                    `<div class="context-menu-item" data-action="${item.action}">
                        <i class="bi ${item.icon}"></i>${item.label}
                    </div>`
                ).join('');

                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';

                // Attach handlers
                contextMenu.querySelectorAll('.context-menu-item').forEach(el => {
                    el.addEventListener('click', () => {
                        const action = el.dataset.action;
                        const handler = items.find(i => i.action === action)?.handler;
                        if (handler) handler();
                        hideContextMenu();
                    });
                });

                // Keep within viewport
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (window.innerWidth - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (window.innerHeight - rect.height - 10) + 'px';
                }
            };

            // Hide context menu
            const hideContextMenu = () => {
                contextMenu.style.display = 'none';
                contextMenu.innerHTML = '';
            };

            // Card grid right-click
            cardGrid.addEventListener('contextmenu', (e) => {
                const cardItem = e.target.closest('.card-item');
                if (!cardItem) return;

                e.preventDefault();
                e.stopPropagation();

                const cardIndex = parseInt(cardItem.dataset.cardIndex);
                const startIndex = (currentPage - 1) * itemsPerPage;
                const card = filteredCards[startIndex + cardIndex];

                if (!card) return;

                const menuItems = [];

                // Bookmark option
                if (isBookmarked(card.id)) {
                    menuItems.push({
                        label: 'ブックマークから削除',
                        icon: 'bi-bookmark-dash',
                        action: 'remove-bookmark',
                        handler: () => removeFromBookmarks(card.id)
                    });
                } else {
                    menuItems.push({
                        label: 'ブックマークに追加',
                        icon: 'bi-bookmark-plus',
                        action: 'add-bookmark',
                        handler: () => addToBookmarks(card)
                    });
                }

                showContextMenu(e.pageX, e.pageY, menuItems);
            });

            // Hide when clicking anywhere
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });
        };

        // ==================== END BOOKMARK FUNCTIONS ====================

        // Event listeners
        document.getElementById('items-per-page').addEventListener('change', (e) => {
            itemsPerPage = parseInt(e.target.value);
            currentPage = 1;
            renderCards();
        });

        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                e.target.closest('button').classList.add('active');
                currentGridSize = e.target.closest('button').dataset.size;
                localStorage.setItem('galleryGridSize', currentGridSize);
                renderCards();
            });
        });

        document.getElementById('sort-select').addEventListener('change', (e) => {
            currentSort = e.target.value;
            applyFilters();
            renderCards();
        });

        document.getElementById('search-input').addEventListener('input', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('code-search-input').addEventListener('input', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('rarity-filter').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('tag-filter').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('clear-filters').addEventListener('click', () => {
            document.getElementById('search-input').value = '';
            document.getElementById('code-search-input').value = '';
            document.getElementById('rarity-filter').value = '';
            document.getElementById('tag-filter').value = '';
            if (document.getElementById('attack-filter')) document.getElementById('attack-filter').value = '';
            if (document.getElementById('defense-filter')) document.getElementById('defense-filter').value = '';

            // Clear level filter
            selectedLevel = '';
            document.querySelectorAll('.level-btn').forEach(btn => btn.classList.remove('active'));
            if (document.querySelector('.level-btn[data-level=""]')) {
                document.querySelector('.level-btn[data-level=""]').classList.add('active');
            }

            // Clear attribute filter
            selectedAttribute = '';
            document.querySelectorAll('.attribute-btn').forEach(btn => btn.classList.remove('active'));
            if (document.querySelector('.attribute-btn[data-attribute=""]')) {
                document.querySelector('.attribute-btn[data-attribute=""]').classList.add('active');
            }

            // Clear race filter
            selectedRace = '';
            document.querySelectorAll('.race-btn').forEach(btn => btn.classList.remove('active'));
            if (document.querySelector('.race-btn[data-race=""]')) {
                document.querySelector('.race-btn[data-race=""]').classList.add('active');
            }

            // Clear card type filter
            selectedCardTypes = [];
            document.querySelectorAll('.card-type-btn').forEach(btn => btn.classList.remove('active'));

            // Reset card type mode to AND
            if (document.getElementById('card-type-and')) {
                document.getElementById('card-type-and').checked = true;
                cardTypeSearchMode = 'and';
            }

            applyFilters();
            renderCards();
        });

        // Level filter buttons
        document.querySelectorAll('.level-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedLevel = btn.dataset.level;
                document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyFilters();
                renderCards();
            });
        });

        // Attribute filter buttons
        document.querySelectorAll('.attribute-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedAttribute = btn.dataset.attribute;
                document.querySelectorAll('.attribute-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyFilters();
                renderCards();
            });
        });

        // Race filter buttons
        document.querySelectorAll('.race-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectedRace = btn.dataset.race;
                document.querySelectorAll('.race-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyFilters();
                renderCards();
            });
        });

        // Card type filter buttons (multiple selection)
        document.querySelectorAll('.card-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                const index = selectedCardTypes.indexOf(type);

                if (index > -1) {
                    // Deselect
                    selectedCardTypes.splice(index, 1);
                    btn.classList.remove('active');
                } else {
                    // Select
                    selectedCardTypes.push(type);
                    btn.classList.add('active');
                }

                applyFilters();
                renderCards();
            });
        });

        // Card type search mode (AND/OR)
        document.querySelectorAll('input[name="card_type_mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                cardTypeSearchMode = e.target.value;
                if (selectedCardTypes.length > 0) {
                    applyFilters();
                    renderCards();
                }
            });
        });

        // Other advanced filters (attack and defense)
        if (document.getElementById('attack-filter')) {
            document.getElementById('attack-filter').addEventListener('input', () => {
                applyFilters();
                renderCards();
            });
        }

        if (document.getElementById('defense-filter')) {
            document.getElementById('defense-filter').addEventListener('input', () => {
                applyFilters();
                renderCards();
            });
        }

        document.getElementById('show-unowned-cards').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        // Tab click event listeners
        document.getElementById('collection-tab').addEventListener('click', () => {
            switchListType('collection');
        });

        document.getElementById('wishlist-tab').addEventListener('click', () => {
            switchListType('wishlist');
        });

        document.getElementById('bookmark-tab').addEventListener('click', () => {
            switchListType('bookmark');
        });

        // Close panel button
        document.getElementById('closePanelBtn').addEventListener('click', closeEditPanel);
        document.getElementById('editPanelOverlay').addEventListener('click', closeEditPanel);

        // Panel save button
        document.getElementById('savePanelCardBtn').addEventListener('click', async () => {
            if (!currentEditingCard || !currentUser) return;

            const newQuantity = parseInt(document.getElementById('panelQuantity').value) || 0;
            const tagsInput = document.getElementById('panelTags').value;
            const newTags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];

            try {
                // Determine collection path based on current list type
                const collectionPath = currentListType === 'collection' ? 'cards' : 'wishlist';
                const cardRef = doc(db, 'users', currentUser.uid, collectionPath, currentEditingCard.id);

                await updateDoc(cardRef, {
                    '枚数': newQuantity,
                    'tags': newTags
                });

                // Update local data
                currentEditingCard.data['枚数'] = newQuantity;
                currentEditingCard.data.tags = newTags;

                // Close panel
                closeEditPanel();

                // Refresh display
                applyFilters();
                renderCards();

                alert('カード情報を更新しました。');
            } catch (error) {
                console.error('Error updating card:', error);
                alert('カード情報の更新に失敗しました。');
            }
        });

        // Panel delete button
        document.getElementById('deletePanelCardBtn').addEventListener('click', async () => {
            if (!currentEditingCard || !currentUser) return;

            if (!confirm(`「${currentEditingCard.data['名前']}」を削除してもよろしいですか？`)) {
                return;
            }

            try {
                // Determine collection path based on current list type
                const collectionPath = currentListType === 'collection' ? 'cards' : 'wishlist';
                const cardRef = doc(db, 'users', currentUser.uid, collectionPath, currentEditingCard.id);

                await deleteDoc(cardRef);

                // Remove from local data
                if (currentListType === 'collection') {
                    collectionCards = collectionCards.filter(c => c.id !== currentEditingCard.id);
                } else {
                    wishlistCards = wishlistCards.filter(c => c.id !== currentEditingCard.id);
                }
                allCards = currentListType === 'collection' ? collectionCards : wishlistCards;

                // Close panel
                closeEditPanel();

                // Refresh display
                applyFilters();
                renderCards();
                populateFilterOptions();

                alert('カードを削除しました。');
            } catch (error) {
                console.error('Error deleting card:', error);
                alert('カードの削除に失敗しました。');
            }
        });

        // ==================== DECK SYSTEM ====================

        // Count card usage across all decks
        const getCardUsageInDecks = (cardId) => {
            const usageMap = {}; // { deckName: count }
            let totalUsed = 0;

            decks.forEach(deck => {
                let deckTotal = 0;

                // Check main deck
                if (deck.mainDeck) {
                    const mainCard = deck.mainDeck.find(c => c.cardId === cardId);
                    if (mainCard) deckTotal += mainCard.quantity;
                }

                // Check extra deck
                if (deck.extraDeck) {
                    const extraCard = deck.extraDeck.find(c => c.cardId === cardId);
                    if (extraCard) deckTotal += extraCard.quantity;
                }

                // Check side deck
                if (deck.sideDeck) {
                    const sideCard = deck.sideDeck.find(c => c.cardId === cardId);
                    if (sideCard) deckTotal += sideCard.quantity;
                }

                if (deckTotal > 0) {
                    usageMap[deck.name || '無題のデッキ'] = deckTotal;
                    totalUsed += deckTotal;
                }
            });

            return { usageMap, totalUsed };
        };

        // Load all decks from Firestore
        const loadDecks = async () => {
            if (!currentUser) return;
            try {
                const decksRef = collection(db, 'users', currentUser.uid, 'decks');
                const snapshot = await getDocs(decksRef);
                decks = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                console.log(`Loaded ${decks.length} decks`);
            } catch (error) {
                console.error('Error loading decks:', error);
            }
        };

        // Save deck to Firestore
        const saveDeck = async () => {
            if (!currentUser || !currentDeck) return;

            const deckData = {
                name: document.getElementById('deckName').value || '無題のデッキ',
                memo: document.getElementById('deckMemo').value || '',
                mainDeck: currentDeck.mainDeck || [],
                extraDeck: currentDeck.extraDeck || [],
                sideDeck: currentDeck.sideDeck || [],
                updatedAt: new Date().toISOString()
            };

            // Validate deck counts
            const mainCount = deckData.mainDeck.reduce((sum, c) => sum + c.quantity, 0);
            const extraCount = deckData.extraDeck.reduce((sum, c) => sum + c.quantity, 0);
            const sideCount = deckData.sideDeck.reduce((sum, c) => sum + c.quantity, 0);

            if (mainCount < 1 || mainCount > 60) {
                alert(`メインデッキは1~60枚である必要があります。\n現在: ${mainCount}枚`);
                return;
            }
            if (extraCount > 15) {
                alert(`エクストラデッキは0~15枚である必要があります。\n現在: ${extraCount}枚`);
                return;
            }
            if (sideCount > 15) {
                alert(`サイドデッキは0~15枚である必要があります。\n現在: ${sideCount}枚`);
                return;
            }

            try {
                // Check for unowned cards and add to wishlist
                const allDeckCards = [
                    ...(deckData.mainDeck || []),
                    ...(deckData.extraDeck || []),
                    ...(deckData.sideDeck || [])
                ];

                console.log('Checking deck cards for unowned:', allDeckCards);

                const unownedCardsToAdd = [];
                for (const deckCard of allDeckCards) {
                    console.log('Checking card:', deckCard.cardId, deckCard.name);

                    // Check if card is in collection
                    const isInCollection = collectionCards.some(c => c.id === deckCard.cardId);
                    console.log('  In collection:', isInCollection);

                    if (!isInCollection) {
                        // Check if already in wishlist
                        const isInWishlist = wishlistCards.some(c => c.id === deckCard.cardId);
                        console.log('  In wishlist:', isInWishlist);

                        if (!isInWishlist) {
                            // Use the card data from deckCard itself
                            // Since we already have name, code, rarity stored in deckCard
                            unownedCardsToAdd.push({
                                cardId: deckCard.cardId,
                                name: deckCard.name,
                                code: deckCard.code,
                                rarity: deckCard.rarity,
                                selectedCiid: deckCard.selectedCiid
                            });
                            console.log('  Added to unowned list');
                        }
                    }
                }

                console.log('Unowned cards to add:', unownedCardsToAdd);

                // Add unowned cards to wishlist
                if (unownedCardsToAdd.length > 0) {
                    const wishlistRef = collection(db, 'users', currentUser.uid, 'wishlist');
                    for (const card of unownedCardsToAdd) {
                        const wishlistData = {
                            名前: card.name,
                            型番: card.code,
                            レアリティ: card.rarity,
                            枚数: 1,
                            tags: [],
                            addedAt: new Date().toISOString()
                        };
                        if (card.selectedCiid) {
                            wishlistData.selectedCiid = card.selectedCiid;
                        }
                        console.log('Adding to wishlist:', card.cardId, wishlistData);
                        await setDoc(doc(wishlistRef, card.cardId), wishlistData);
                    }
                    console.log(`Added ${unownedCardsToAdd.length} unowned cards to wishlist`);
                }

                if (currentDeck.id) {
                    // Update existing deck
                    const deckRef = doc(db, 'users', currentUser.uid, 'decks', currentDeck.id);
                    await updateDoc(deckRef, deckData);
                    if (unownedCardsToAdd.length > 0) {
                        alert(`デッキを保存しました\n未所持カード ${unownedCardsToAdd.length} 枚をウィッシュリストに追加しました`);
                    } else {
                        alert('デッキを保存しました');
                    }
                } else {
                    // Create new deck
                    deckData.createdAt = new Date().toISOString();
                    const decksRef = collection(db, 'users', currentUser.uid, 'decks');
                    const docRef = await addDoc(decksRef, deckData);
                    currentDeck.id = docRef.id;
                    if (unownedCardsToAdd.length > 0) {
                        alert(`デッキを作成しました\n未所持カード ${unownedCardsToAdd.length} 枚をウィッシュリストに追加しました`);
                    } else {
                        alert('デッキを作成しました');
                    }
                }

                // Reload data to reflect wishlist changes
                if (unownedCardsToAdd.length > 0) {
                    await loadAllData(currentUser.uid);
                } else {
                    await loadDecks();
                }
                renderDeckList();
                renderCards(); // Re-render cards to update stock badges
            } catch (error) {
                console.error('Error saving deck:', error);
                alert('デッキの保存に失敗しました');
            }
        };

        // Delete deck
        const deleteDeck = async () => {
            if (!currentUser || !currentDeck || !currentDeck.id) return;

            if (!confirm('このデッキを削除しますか？')) return;

            try {
                const deckRef = doc(db, 'users', currentUser.uid, 'decks', currentDeck.id);
                await deleteDoc(deckRef);
                alert('デッキを削除しました');
                closeDeckBuilder();
                await loadDecks();
                renderDeckList();
                renderCards(); // Re-render cards to update stock badges
            } catch (error) {
                console.error('Error deleting deck:', error);
                alert('デッキの削除に失敗しました');
            }
        };

        // Open deck list panel
        const openDeckList = () => {
            deckListPanel.classList.add('active');
        };

        // Close deck list panel
        const closeDeckList = () => {
            deckListPanel.classList.remove('active');
        };

        // Open deck builder panel
        const openDeckBuilder = async (deck = null) => {
            currentDeck = deck || { mainDeck: [], extraDeck: [], sideDeck: [] };

            document.getElementById('deckName').value = currentDeck.name || '';
            document.getElementById('deckMemo').value = currentDeck.memo || '';
            document.getElementById('deckBuilderTitle').textContent = deck ? 'デッキ編集' : '新規デッキ';

            await renderDeckCards();

            document.getElementById('deckBuilderPanel').classList.add('active');
            document.body.classList.add('deck-builder-open');

            // Hide delete button for new decks
            document.getElementById('deleteDeckBtn').style.display = deck && deck.id ? 'block' : 'none';
        };

        // Close deck builder panel
        const closeDeckBuilder = () => {
            document.getElementById('deckBuilderPanel').classList.remove('active');
            document.body.classList.remove('deck-builder-open');
            currentDeck = null;
        };

        // Render deck list in modal
        const renderDeckList = () => {
            const container = document.getElementById('deck-list-container');

            if (decks.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4">
                        <i class="bi bi-inbox" style="font-size: 3rem; color: #ccc;"></i>
                        <p class="text-muted mt-2">デッキがありません</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = decks.map(deck => {
                const mainCount = deck.mainDeck ? deck.mainDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const extraCount = deck.extraDeck ? deck.extraDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const sideCount = deck.sideDeck ? deck.sideDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const cardCount = mainCount + extraCount + sideCount;
                const cardTypes = (deck.mainDeck?.length || 0) + (deck.extraDeck?.length || 0) + (deck.sideDeck?.length || 0);

                return `
                    <div class="deck-list-item" onclick="viewDeck('${deck.id}')">
                        <div class="deck-list-item-header">
                            <div class="deck-list-item-name">${escapeHtml(deck.name || '無題')}</div>
                            <div class="deck-list-item-actions">
                                <button class="btn btn-sm btn-outline-info" onclick="event.stopPropagation(); viewDeck('${deck.id}')" title="閲覧">
                                    <i class="bi bi-eye"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-primary" onclick="event.stopPropagation(); editDeck('${deck.id}')" title="編集">
                                    <i class="bi bi-pencil"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="event.stopPropagation(); deleteDeckFromList('${deck.id}')" title="削除">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                        ${deck.memo ? `<div class="deck-list-item-memo">${escapeHtml(deck.memo)}</div>` : ''}
                        <div class="deck-list-item-stats">
                            <span><i class="bi bi-collection"></i> ${cardCount}枚</span>
                            <span><i class="bi bi-card-list"></i> ${cardTypes}種</span>
                            <span><i class="bi bi-clock"></i> ${new Date(deck.updatedAt || deck.createdAt).toLocaleDateString('ja-JP')}</span>
                        </div>
                    </div>
                `;
            }).join('');
        };

        // Edit deck (called from deck list)
        window.editDeck = (deckId) => {
            const deck = decks.find(d => d.id === deckId);
            if (deck) {
                closeDeckList();
                openDeckBuilder(deck);
            }
        };

        // Delete deck from list
        window.deleteDeckFromList = async (deckId) => {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return;

            if (!confirm(`「${deck.name || '無題'}」を削除してもよろしいですか？`)) {
                return;
            }

            try {
                if (!currentUser) return;

                const deckRef = doc(db, 'users', currentUser.uid, 'decks', deckId);
                await deleteDoc(deckRef);

                // Remove from local array
                decks = decks.filter(d => d.id !== deckId);
                renderDeckList();

                alert('デッキを削除しました');
            } catch (error) {
                console.error('Error deleting deck:', error);
                alert('デッキの削除に失敗しました');
            }
        };

        // View deck in modal
        let currentViewingDeck = null;

        window.viewDeck = async (deckId) => {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return;

            currentViewingDeck = deck;

            // Set deck name
            document.getElementById('viewDeckName').textContent = deck.name || '無題のデッキ';

            // Render deck view
            await renderDeckView(deck);

            // Load saved card details visibility preference
            const hideCardDetails = localStorage.getItem('deckViewHideCardDetails');
            const deckViewContent = document.getElementById('deckViewContent');
            const btn = document.getElementById('toggleDeckViewDetailsBtn');

            if (hideCardDetails === 'true') {
                deckViewContent.classList.add('hide-card-details');
                btn.classList.remove('btn-outline-secondary');
                btn.classList.add('btn-secondary');
            } else {
                deckViewContent.classList.remove('hide-card-details');
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-outline-secondary');
            }

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('deckViewModal'));
            modal.show();
        };

        const renderDeckView = async (deck) => {
            const container = document.getElementById('deckViewContent');

            const renderSection = async (title, cards, sectionId) => {
                if (!cards || cards.length === 0) return '';

                // Expand cards based on quantity
                const expandedCards = cards.flatMap(card =>
                    Array(card.quantity).fill(card)
                );

                let html = `
                    <div class="deck-view-section">
                        <div class="deck-view-section-title">${title} (${expandedCards.length}枚)</div>
                        <div class="deck-view-grid" id="${sectionId}">
                `;

                // Add placeholder cards
                expandedCards.forEach((card, index) => {
                    html += `
                        <div class="deck-view-card" data-card-name="${escapeHtml(card.name)}">
                            <div class="deck-view-card-placeholder">
                                <i class="bi bi-card-image"></i>
                            </div>
                            ${card.rarity ? `<div class="deck-view-card-rarity">${escapeHtml(card.rarity)}</div>` : ''}
                            ${card.code ? `<div class="deck-view-card-code">${escapeHtml(card.code)}</div>` : ''}
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;

                return html;
            };

            // Build HTML
            let html = `
                <div style="text-align: center; margin-bottom: 2rem;">
                    <h3>${escapeHtml(deck.name || '無題のデッキ')}</h3>
                    ${deck.memo ? `<p style="color: #6c757d;">${escapeHtml(deck.memo)}</p>` : ''}
                </div>
            `;

            html += await renderSection('メインデッキ', deck.mainDeck, 'view-main-deck');
            html += await renderSection('エクストラデッキ', deck.extraDeck, 'view-extra-deck');
            html += await renderSection('サイドデッキ', deck.sideDeck, 'view-side-deck');

            container.innerHTML = html;

            // Load images asynchronously
            const loadSectionImages = async (cards, sectionId) => {
                if (!cards || cards.length === 0) return;

                const expandedCards = cards.flatMap(card =>
                    Array(card.quantity).fill(card)
                );

                const cardElements = document.querySelectorAll(`#${sectionId} .deck-view-card`);

                for (let i = 0; i < expandedCards.length; i++) {
                    const card = expandedCards[i];
                    const cardElement = cardElements[i];

                    if (!cardElement) continue;

                    try {
                        // Decode HTML entities in card name before fetching image
                        const decodedCardName = decodeHtmlEntities(card.name);
                        // Use selectedCiid if available, otherwise default to '1'
                        const ciid = card.selectedCiid || '1';
                        const imageUrl = await getCardImageUrl(decodedCardName, ciid);
                        if (imageUrl) {
                            // Replace placeholder with image, keeping code and rarity elements
                            const placeholder = cardElement.querySelector('.deck-view-card-placeholder');
                            if (placeholder) {
                                placeholder.outerHTML = `<img src="${imageUrl}" alt="${escapeHtml(decodedCardName)}">`;
                            }
                        }
                    } catch (error) {
                        console.error(`Failed to load image for ${card.name}:`, error);
                    }
                }
            };

            // Load images for all sections
            await Promise.all([
                loadSectionImages(deck.mainDeck, 'view-main-deck'),
                loadSectionImages(deck.extraDeck, 'view-extra-deck'),
                loadSectionImages(deck.sideDeck, 'view-side-deck')
            ]);
        };

        // Export deck as image
        document.getElementById('exportDeckImageBtn').addEventListener('click', async () => {
            if (!currentViewingDeck) return;

            const content = document.getElementById('deckViewContent');

            // Save original width
            const originalWidth = content.style.width;
            const originalMaxWidth = content.style.maxWidth;

            try {
                // Set fixed width for consistent export (1080px target)
                content.style.width = '1080px';
                content.style.maxWidth = '1080px';

                // Wait a moment for layout to update
                await new Promise(resolve => setTimeout(resolve, 100));

                const canvas = await html2canvas(content, {
                    scale: 1,
                    backgroundColor: '#ffffff',
                    logging: false,
                    useCORS: true,
                    width: 1080
                });

                // Always resize to exactly 1080px width
                const targetWidth = 1080;
                const scale = targetWidth / canvas.width;
                const resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = targetWidth;
                resizedCanvas.height = canvas.height * scale;

                const ctx = resizedCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, 0, resizedCanvas.width, resizedCanvas.height);

                // Convert to blob and download
                resizedCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${currentViewingDeck.name || 'デッキ'}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            } catch (error) {
                console.error('Error exporting deck image:', error);
                alert('画像の出力に失敗しました');
            } finally {
                // Restore original width
                content.style.width = originalWidth;
                content.style.maxWidth = originalMaxWidth;
            }
        });

        // Toggle card details (code and rarity) visibility in deck view modal
        document.getElementById('toggleDeckViewDetailsBtn').addEventListener('click', () => {
            const deckViewContent = document.getElementById('deckViewContent');
            const btn = document.getElementById('toggleDeckViewDetailsBtn');
            const isHidden = deckViewContent.classList.toggle('hide-card-details');

            // Update button appearance
            if (isHidden) {
                btn.classList.remove('btn-outline-secondary');
                btn.classList.add('btn-secondary');
            } else {
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-outline-secondary');
            }

            // Save preference
            localStorage.setItem('deckViewHideCardDetails', isHidden.toString());
            console.log('Deck view card details visibility toggled:', isHidden ? 'hidden' : 'visible');
        });

        // Render cards in deck builder
        const renderDeckCards = async () => {
            if (!currentDeck) return;

            // Helper function to render a deck section
            const renderDeckSection = async (deckType, cards, containerId, countId) => {
                const container = document.getElementById(containerId);
                const placeholder = document.querySelector(`#${containerId.replace('CardsList', 'DropZone')} .deck-drop-placeholder`);
                const count = cards.reduce((sum, c) => sum + c.quantity, 0);

                document.getElementById(countId).textContent = count;

                if (cards.length === 0) {
                    container.innerHTML = '';
                    if (placeholder) placeholder.style.display = 'block';
                    return;
                }

                if (placeholder) placeholder.style.display = 'none';

                // First render placeholder cards in grid (repeat each card by its quantity)
                container.innerHTML = `<div class="deck-cards-grid">` + cards.flatMap((deckCard, index) => {
                    const decodedCardName = decodeHtmlEntities(deckCard.name);
                    // Check if card is unowned
                    const isUnowned = !collectionCards.some(c => c.id === deckCard.cardId);
                    const unownedClass = isUnowned ? ' unowned' : '';
                    return Array(deckCard.quantity).fill(null).map((_, copyIndex) => {
                        return `
                        <div class="deck-card-item${unownedClass}" data-card-index="${index}" data-copy-index="${copyIndex}" data-deck-type="${deckType}" data-card-id="${deckCard.cardId}" draggable="true">
                            <div class="deck-card-image-container">
                                <img data-card-name="${escapeHtml(decodedCardName)}" alt="${escapeHtml(decodedCardName)}" style="display:none;">
                                <div class="deck-card-image-placeholder">
                                    <i class="bi bi-card-image"></i>
                                </div>
                                <div class="deck-card-rarity">${escapeHtml(deckCard.rarity || '')}</div>
                                <div class="deck-card-code">${escapeHtml(deckCard.code || '')}</div>
                            </div>
                        </div>
                    `;
                    });
                }).join('') + `</div>`;

                // Then load images asynchronously
                const grid = container.querySelector('.deck-cards-grid');
                if (grid) {
                    for (let i = 0; i < cards.length; i++) {
                        const card = cards[i];
                        const cardItems = grid.querySelectorAll(`[data-card-index="${i}"]`);

                        try {
                            // Decode HTML entities in card name before fetching image
                            const decodedCardName = decodeHtmlEntities(card.name);
                            // Use selectedCiid if available, otherwise default to '1'
                            const ciid = card.selectedCiid || '1';
                            const imageUrl = await getCardImageUrl(decodedCardName, ciid);
                            if (imageUrl) {
                                // Apply the same image to all copies of this card
                                cardItems.forEach(cardItem => {
                                    const img = cardItem.querySelector('img');
                                    const placeholder = cardItem.querySelector('.deck-card-image-placeholder');
                                    img.src = imageUrl;
                                    img.style.display = 'block';
                                    placeholder.style.display = 'none';
                                });
                            }
                        } catch (error) {
                            console.error(`Failed to load image for ${card.name}:`, error);
                        }
                    }

                    // Setup drag events for deck cards
                    grid.querySelectorAll('.deck-card-item').forEach(cardItem => {
                        cardItem.addEventListener('dragstart', (e) => {
                            const cardIndex = parseInt(cardItem.dataset.cardIndex);
                            const copyIndex = parseInt(cardItem.dataset.copyIndex);
                            const sourceDeckType = cardItem.dataset.deckType;
                            draggedDeckCard = {
                                card: cards[cardIndex],
                                cardIndex: cardIndex,
                                copyIndex: copyIndex,
                                sourceDeckType: sourceDeckType,
                                element: cardItem
                            };
                            cardItem.classList.add('dragging');
                            e.dataTransfer.effectAllowed = 'move';
                        });

                        cardItem.addEventListener('dragend', (e) => {
                            cardItem.classList.remove('dragging');
                        });

                        // Reordering within same deck
                        cardItem.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            e.dataTransfer.dropEffect = 'move';

                            if (draggedDeckCard && draggedDeckCard.sourceDeckType === deckType &&
                                draggedDeckCard.element !== cardItem) {
                                const rect = cardItem.getBoundingClientRect();
                                const midpoint = rect.left + rect.width / 2;

                                if (e.clientX < midpoint) {
                                    cardItem.style.borderLeft = '3px solid #667eea';
                                    cardItem.style.borderRight = '';
                                } else {
                                    cardItem.style.borderRight = '3px solid #667eea';
                                    cardItem.style.borderLeft = '';
                                }
                            }
                        });

                        cardItem.addEventListener('dragleave', (e) => {
                            cardItem.style.borderLeft = '';
                            cardItem.style.borderRight = '';
                        });

                        cardItem.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            cardItem.style.borderLeft = '';
                            cardItem.style.borderRight = '';

                            if (!draggedDeckCard || draggedDeckCard.sourceDeckType !== deckType) {
                                return;
                            }

                            const targetCardIndex = parseInt(cardItem.dataset.cardIndex);
                            const targetCopyIndex = parseInt(cardItem.dataset.copyIndex);

                            // Calculate positions in the flat array
                            const sourcePosition = cards.slice(0, draggedDeckCard.cardIndex).reduce((sum, c) => sum + c.quantity, 0) + draggedDeckCard.copyIndex;
                            const targetPosition = cards.slice(0, targetCardIndex).reduce((sum, c) => sum + c.quantity, 0) + targetCopyIndex;

                            if (sourcePosition === targetPosition) return;

                            // Determine insert position based on mouse position
                            const rect = cardItem.getBoundingClientRect();
                            const midpoint = rect.left + rect.width / 2;
                            const insertBefore = e.clientX < midpoint;
                            const finalTargetPosition = insertBefore ? targetPosition : targetPosition + 1;

                            // Reorder the cards
                            await reorderDeckCards(deckType, sourcePosition, finalTargetPosition);
                        });
                    });
                }
            };

            // Render each section
            await renderDeckSection('main', currentDeck.mainDeck || [], 'mainDeckCardsList', 'mainDeckCount');
            await renderDeckSection('extra', currentDeck.extraDeck || [], 'extraDeckCardsList', 'extraDeckCount');
            await renderDeckSection('side', currentDeck.sideDeck || [], 'sideDeckCardsList', 'sideDeckCount');
        };

        // Reorder cards within a deck
        const reorderDeckCards = async (deckType, sourcePosition, targetPosition) => {
            if (!currentDeck || sourcePosition === targetPosition) return;

            const deckKey = deckType === 'main' ? 'mainDeck' :
                          deckType === 'extra' ? 'extraDeck' : 'sideDeck';

            const deck = currentDeck[deckKey] || [];

            // Convert cards with quantities to flat array
            const flatCards = [];
            deck.forEach((card, cardIndex) => {
                for (let i = 0; i < card.quantity; i++) {
                    flatCards.push({
                        ...card,
                        originalCardIndex: cardIndex,
                        copyIndex: i
                    });
                }
            });

            // Adjust target position if moving forward
            const adjustedTargetPosition = sourcePosition < targetPosition ? targetPosition - 1 : targetPosition;

            // Move the card
            const [movedCard] = flatCards.splice(sourcePosition, 1);
            flatCards.splice(adjustedTargetPosition, 0, movedCard);

            // Rebuild deck array from flat cards
            const newDeck = [];
            const cardMap = new Map();

            flatCards.forEach(flatCard => {
                const key = flatCard.cardId;
                if (!cardMap.has(key)) {
                    cardMap.set(key, {
                        cardId: flatCard.cardId,
                        name: flatCard.name,
                        code: flatCard.code,
                        rarity: flatCard.rarity,
                        selectedCiid: flatCard.selectedCiid,
                        quantity: 0,
                        positions: []
                    });
                }
                const entry = cardMap.get(key);
                entry.quantity++;
                entry.positions.push(newDeck.length);
            });

            // Build final array maintaining new order
            flatCards.forEach(flatCard => {
                const existingIndex = newDeck.findIndex(c =>
                    c.cardId === flatCard.cardId &&
                    c.quantity < cardMap.get(flatCard.cardId).quantity
                );

                if (existingIndex === -1) {
                    // Create new entry
                    newDeck.push({
                        cardId: flatCard.cardId,
                        name: flatCard.name,
                        code: flatCard.code,
                        rarity: flatCard.rarity,
                        selectedCiid: flatCard.selectedCiid,
                        quantity: 1
                    });
                } else {
                    // Increment quantity of existing entry
                    newDeck[existingIndex].quantity++;
                }
            });

            // Merge consecutive same cards
            const mergedDeck = [];
            for (let i = 0; i < newDeck.length; i++) {
                if (mergedDeck.length > 0 &&
                    mergedDeck[mergedDeck.length - 1].cardId === newDeck[i].cardId) {
                    mergedDeck[mergedDeck.length - 1].quantity += newDeck[i].quantity;
                } else {
                    mergedDeck.push(newDeck[i]);
                }
            }

            currentDeck[deckKey] = mergedDeck;
            await renderDeckCards();
        };

        // Add card to deck
        const addCardToDeck = async (cardData, deckType) => {
            if (!currentDeck) {
                alert('デッキを開いてください');
                return;
            }

            // Determine which deck to add to
            const deckKey = deckType === 'main' ? 'mainDeck' :
                          deckType === 'extra' ? 'extraDeck' : 'sideDeck';

            if (!currentDeck[deckKey]) {
                currentDeck[deckKey] = [];
            }

            // Check count limits before adding
            const currentCount = currentDeck[deckKey].reduce((sum, c) => sum + c.quantity, 0);
            const limit = deckType === 'main' ? 60 : 15;

            if (currentCount >= limit) {
                const deckName = deckType === 'main' ? 'メインデッキ' :
                               deckType === 'extra' ? 'エクストラデッキ' : 'サイドデッキ';
                alert(`${deckName}は${limit}枚までです。`);
                return;
            }

            // Check if card already exists in this deck
            const existingIndex = currentDeck[deckKey].findIndex(c => c.cardId === cardData.id);

            if (existingIndex >= 0) {
                currentDeck[deckKey][existingIndex].quantity++;
            } else {
                const deckCard = {
                    cardId: cardData.id,
                    name: cardData.data['名前'],
                    code: cardData.data['型番'],
                    rarity: cardData.data['レアリティ'],
                    quantity: 1
                };
                // Include selectedCiid if it exists
                if (cardData.data.selectedCiid) {
                    deckCard.selectedCiid = cardData.data.selectedCiid;
                }
                currentDeck[deckKey].push(deckCard);
            }

            await renderDeckCards();
        };

        // Remove card from deck
        const removeCardFromDeck = async (card, sourceDeckType) => {
            if (!currentDeck) return;

            const deckKey = sourceDeckType === 'main' ? 'mainDeck' :
                          sourceDeckType === 'extra' ? 'extraDeck' : 'sideDeck';

            const existingIndex = currentDeck[deckKey].findIndex(c => c.cardId === card.cardId);
            if (existingIndex !== -1) {
                if (currentDeck[deckKey][existingIndex].quantity > 1) {
                    currentDeck[deckKey][existingIndex].quantity--;
                } else {
                    currentDeck[deckKey].splice(existingIndex, 1);
                }
                await renderDeckCards();
            }
        };

        // Move card between deck sections
        const moveCardBetweenDecks = async (card, sourceDeckType, targetDeckType) => {
            if (!currentDeck || sourceDeckType === targetDeckType) return;

            // Check target deck limits first
            const targetKey = targetDeckType === 'main' ? 'mainDeck' :
                           targetDeckType === 'extra' ? 'extraDeck' : 'sideDeck';

            if (!currentDeck[targetKey]) {
                currentDeck[targetKey] = [];
            }

            const currentCount = currentDeck[targetKey].reduce((sum, c) => sum + c.quantity, 0);
            const limit = targetDeckType === 'main' ? 60 : 15;

            if (currentCount >= limit) {
                const deckName = targetDeckType === 'main' ? 'メインデッキ' :
                               targetDeckType === 'extra' ? 'エクストラデッキ' : 'サイドデッキ';
                alert(`${deckName}は${limit}枚までです。`);
                return;
            }

            // Remove from source
            const sourceKey = sourceDeckType === 'main' ? 'mainDeck' :
                           sourceDeckType === 'extra' ? 'extraDeck' : 'sideDeck';
            const existingIndex = currentDeck[sourceKey].findIndex(c => c.cardId === card.cardId);
            if (existingIndex === -1) return;

            if (currentDeck[sourceKey][existingIndex].quantity > 1) {
                currentDeck[sourceKey][existingIndex].quantity--;
            } else {
                currentDeck[sourceKey].splice(existingIndex, 1);
            }

            // Add to target deck
            const targetIndex = currentDeck[targetKey].findIndex(c => c.cardId === card.cardId);
            if (targetIndex !== -1) {
                currentDeck[targetKey][targetIndex].quantity++;
            } else {
                currentDeck[targetKey].push({
                    cardId: card.cardId,
                    name: card.name,
                    code: card.code,
                    rarity: card.rarity,
                    quantity: 1
                });
            }

            await renderDeckCards();
        };

        // Setup drag and drop
        const setupDragAndDrop = () => {
            const setupDropZone = (dropZoneId, deckType) => {
                const dropZone = document.getElementById(dropZoneId);
                if (!dropZone) return;

                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });

                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });

                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');

                    // Handle card from gallery
                    if (draggedCard) {
                        addCardToDeck(draggedCard, deckType);
                        draggedCard = null;
                    }
                    // Handle card from deck (moving between decks)
                    else if (draggedDeckCard) {
                        await moveCardBetweenDecks(draggedDeckCard.card, draggedDeckCard.sourceDeckType, deckType);
                        draggedDeckCard = null;
                    }
                });
            };

            setupDropZone('mainDeckDropZone', 'main');
            setupDropZone('extraDeckDropZone', 'extra');
            setupDropZone('sideDeckDropZone', 'side');

            // Setup drop on panel outside (for card removal)
            const deckBuilderPanel = document.getElementById('deckBuilderPanel');
            if (deckBuilderPanel) {
                deckBuilderPanel.addEventListener('dragover', (e) => {
                    // Only allow dropping deck cards outside drop zones
                    if (draggedDeckCard && !e.target.closest('.deck-drop-zone')) {
                        e.preventDefault();
                    }
                });

                deckBuilderPanel.addEventListener('drop', async (e) => {
                    // If dropped outside drop zones, remove card
                    if (draggedDeckCard && !e.target.closest('.deck-drop-zone')) {
                        e.preventDefault();
                        await removeCardFromDeck(draggedDeckCard.card, draggedDeckCard.sourceDeckType);
                        draggedDeckCard = null;
                    }
                });
            }
        };

        // Event listeners for deck system
        document.getElementById('deck-manager-btn').addEventListener('click', async () => {
            await loadDecks();
            renderDeckList();
            openDeckList();
        });

        document.getElementById('create-new-deck-btn').addEventListener('click', () => {
            closeDeckList();
            openDeckBuilder();
        });

        document.getElementById('closeDeckListBtn').addEventListener('click', closeDeckList);

        document.getElementById('closeDeckBuilderBtn').addEventListener('click', closeDeckBuilder);

        // Toggle card details (code and rarity) visibility
        document.getElementById('toggleCardDetailsBtn').addEventListener('click', () => {
            const deckBuilderPanel = document.getElementById('deckBuilderPanel');
            const btn = document.getElementById('toggleCardDetailsBtn');
            const isHidden = deckBuilderPanel.classList.toggle('hide-card-details');

            // Update button appearance
            if (isHidden) {
                btn.classList.remove('btn-outline-secondary');
                btn.classList.add('btn-secondary');
            } else {
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-outline-secondary');
            }

            // Save preference
            localStorage.setItem('deckBuilderHideCardDetails', isHidden.toString());
            console.log('Card details visibility toggled:', isHidden ? 'hidden' : 'visible');
        });

        document.getElementById('saveDeckBtn').addEventListener('click', saveDeck);
        document.getElementById('deleteDeckBtn').addEventListener('click', deleteDeck);

        // Initialize drag and drop
        setupDragAndDrop();

        // Initialize context menu
        setupContextMenu();

        // ==================== END DECK SYSTEM ====================

        // Initialize
        const init = async () => {
            showLoading(true);

            // Initialize image cache manager
            try {
                await imageCacheManager.init();
                console.log('Image cache manager initialized');
            } catch (error) {
                console.error('Failed to initialize image cache manager:', error);
            }

            await loadCardData();

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // Check if user is VIP member
                    const vipData = localStorage.getItem('vip_membership');
                    let isVipMember = false;

                    if (vipData) {
                        try {
                            const parsed = JSON.parse(vipData);
                            if (parsed.active && parsed.verified) {
                                isVipMember = true;
                            }
                        } catch (e) {
                            console.error('Error parsing VIP data:', e);
                        }
                    }

                    // Redirect non-VIP users
                    if (!isVipMember) {
                        alert('このページはVIPメンバー専用です。\n\nカードリストページに戻ります。');
                        window.location.href = 'card_list.html';
                        return;
                    }

                    // User is VIP, proceed with loading
                    currentUser = user;
                    loadAllData(user.uid);

                    // Load saved grid size
                    const savedSize = localStorage.getItem('galleryGridSize');
                    if (savedSize) {
                        currentGridSize = savedSize;
                        document.querySelectorAll('.size-btn').forEach(btn => {
                            if (btn.dataset.size === savedSize) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        });
                    }

                    // Load saved list type
                    const savedListType = localStorage.getItem('galleryListType');
                    if (savedListType && (savedListType === 'collection' || savedListType === 'wishlist' || savedListType === 'bookmark')) {
                        currentListType = savedListType;
                    }

                    // Load saved card details visibility preference
                    const hideCardDetails = localStorage.getItem('deckBuilderHideCardDetails');
                    if (hideCardDetails === 'true') {
                        const deckBuilderPanel = document.getElementById('deckBuilderPanel');
                        const btn = document.getElementById('toggleCardDetailsBtn');
                        if (deckBuilderPanel && btn) {
                            deckBuilderPanel.classList.add('hide-card-details');
                            btn.classList.remove('btn-outline-secondary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                } else {
                    // Redirect to login page
                    alert('ログインが必要です。');
                    window.location.href = 'card_list.html';
                }
            });
        };

        init();
    </script>

    <!-- Navbar Scroll Effect -->
    <script>
        // Add scroll effect to navbar
        window.addEventListener('scroll', function() {
            const navbar = document.querySelector('.navbar-custom');
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });
    </script>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu"></div>

</body>
</html>
