<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カードギャラリー - グリッド表示</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <script src="image_cache_manager.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .header-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .controls-bar {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .view-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Grid layout styles */
        .card-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
            transition: margin-left 0.3s ease;
        }

        .card-grid.deck-builder-open {
            margin-left: 420px;
        }

        .card-grid.size-small {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .card-grid.size-medium {
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        .card-grid.size-large {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .card-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .card-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        /* Unowned card styles */
        .card-item.unowned {
            opacity: 0.7;
            border-color: #ccc;
        }

        .card-item.unowned .card-image-container img {
            filter: grayscale(100%);
        }

        .card-item.unowned:hover {
            opacity: 0.85;
        }

        .card-item.unowned .card-quantity {
            color: #6c757d;
        }

        .unowned-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(108, 117, 125, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 1;
        }

        .card-image-container {
            width: 100%;
            aspect-ratio: 0.686;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .card-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        .card-item:hover .card-image-container img {
            transform: scale(1.05);
        }

        .card-image-placeholder {
            font-size: 4rem;
            color: rgba(0,0,0,0.1);
        }

        .card-info {
            padding: 0.75rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .card-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
            min-height: 2.6em;
            color: #2c3e50;
        }

        .card-code {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .card-rarity {
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .card-quantity {
            font-size: 0.9rem;
            font-weight: bold;
            color: #28a745;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: auto;
        }

        .card-tags .badge {
            font-size: 0.65rem;
            padding: 0.25rem 0.5rem;
        }

        .stock-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin: 2rem 0;
        }

        .stats-bar {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-overlay.hidden {
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .card-grid.size-small {
                grid-template-columns: repeat(5, 1fr);
                gap: 0.25rem;
            }

            .card-grid.size-medium {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 0.75rem;
            }

            .card-grid.size-large {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }

            .card-info {
                padding: 0.5rem;
            }

            .card-name {
                font-size: 0.8rem;
            }

            .controls-bar {
                padding: 0.75rem;
            }

            .view-controls {
                font-size: 0.9rem;
            }
        }

        .filter-section {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .filter-section .form-control,
        .filter-section .form-select {
            font-size: 0.9rem;
        }

        /* Side panel styles */
        .edit-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1050;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .edit-panel-overlay.show {
            display: block;
            opacity: 1;
        }

        .edit-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 90%;
            max-width: 900px;
            height: 100vh;
            background: white;
            z-index: 1051;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.3);
        }

        .edit-panel.show {
            right: 0;
        }

        .edit-panel-content {
            display: flex;
            height: 100%;
            flex-direction: row;
        }

        .edit-panel-left {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
        }

        .edit-panel-left img {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .edit-panel-right {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            background: white;
        }

        .edit-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .edit-panel-header h3 {
            margin: 0;
            color: #2c3e50;
        }

        .edit-panel-close {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .edit-panel-close:hover {
            background: #f8f9fa;
            color: #000;
        }

        .edit-panel-form .form-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }

        .edit-panel-form .form-control,
        .edit-panel-form .form-control-plaintext {
            margin-bottom: 1.5rem;
        }

        .edit-panel-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #e9ecef;
        }

        .edit-panel-actions button {
            flex: 1;
        }

        /* Deck Builder Panel Styles */
        /* Deck List Panel Styles */
        .deck-list-panel {
            position: fixed;
            top: 0;
            left: -450px;
            width: 450px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 10px rgba(0,0,0,0.2);
            z-index: 1060;
            transition: left 0.3s ease;
            overflow-y: auto;
        }

        .deck-list-panel.active {
            left: 0;
        }

        .deck-list-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .deck-list-header h4 {
            margin: 0;
        }

        .deck-list-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .deck-list-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .deck-list-content {
            padding: 1.5rem;
        }

        .deck-builder-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 10px rgba(0,0,0,0.2);
            z-index: 1050;
            transition: left 0.3s ease;
            overflow-y: auto;
        }

        .deck-builder-panel.active {
            left: 0;
        }

        .deck-builder-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .deck-builder-header h4 {
            margin: 0;
        }

        .deck-builder-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .deck-builder-close:hover {
            background: rgba(255,255,255,0.2);
        }

        .deck-builder-content {
            padding: 1.5rem;
        }

        .deck-info-section {
            margin-bottom: 1.5rem;
        }

        .deck-cards-section {
            margin-bottom: 1.5rem;
        }

        .deck-drop-zone {
            min-height: 300px;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            background: #f8f9fa;
            position: relative;
        }

        .deck-drop-zone.drag-over {
            border-color: #667eea;
            background: #e7f1ff;
        }

        .deck-drop-placeholder {
            text-align: center;
            color: #adb5bd;
            padding: 2rem;
        }

        .deck-drop-placeholder p {
            margin: 0.5rem 0 0 0;
        }

        .deck-cards-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.75rem;
        }

        .deck-card-item {
            transition: all 0.2s;
        }

        .deck-card-item:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .deck-card-image-container {
            width: 100%;
            aspect-ratio: 0.686;
            background: #f8f9fa;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .deck-card-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .deck-card-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #adb5bd;
            font-size: 2rem;
        }

        .deck-card-rarity {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            line-height: 1.2;
        }

        .deck-card-code {
            position: absolute;
            bottom: 4px;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            font-size: 0.5rem;
            text-align: center;
            line-height: 1.2;
        }

        .deck-builder-actions {
            padding-top: 1rem;
            border-top: 1px solid #dee2e6;
        }

        /* Drag and drop styles */
        .card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .card-item.draggable {
            cursor: grab;
        }

        .deck-card-item {
            cursor: grab;
        }

        .deck-card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .deck-list-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.2s;
        }

        .deck-list-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-color: #667eea;
        }

        .deck-list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.5rem;
        }

        .deck-list-item-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #2c3e50;
            flex: 1;
        }

        .deck-list-item-actions {
            display: flex;
            gap: 0.5rem;
        }

        .deck-list-item-memo {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .deck-list-item-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: #495057;
        }

        @media (max-width: 768px) {
            .deck-cards-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .deck-list-panel {
                width: 100%;
                left: -100%;
            }

            .deck-list-panel.active {
                left: 0;
            }

            .deck-builder-panel {
                width: 100%;
                left: -100%;
            }

            .edit-panel {
                width: 100%;
                max-width: 100%;
            }

            .edit-panel-content {
                flex-direction: column;
            }

            .edit-panel-left {
                min-height: 300px;
                max-height: 40vh;
            }

            .edit-panel-left img {
                max-height: 35vh;
            }

            .edit-panel-right {
                flex: none;
            }

            .card-grid.deck-builder-open {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div class="loading-overlay hidden" id="loading-overlay">
        <div class="spinner-border text-light" style="width: 3rem; height: 3rem;" role="status">
            <span class="visually-hidden">読み込み中...</span>
        </div>
    </div>

    <!-- Header -->
    <div class="header-section">
        <div class="container">
            <h1 class="mb-2">
                <i class="bi bi-grid-3x3-gap"></i> カードギャラリー
            </h1>
        </div>
    </div>

    <div class="container">
        <!-- List type selector tabs -->
        <ul class="nav nav-tabs mb-3" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="collection-tab" data-list-type="collection" type="button">
                    <i class="bi bi-collection"></i> 所持カード
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="wishlist-tab" data-list-type="wishlist" type="button">
                    <i class="bi bi-star"></i> ウィッシュリスト
                </button>
            </li>
        </ul>

        <!-- Stats bar -->
        <div class="stats-bar">
            <div class="row text-center">
                <div class="col-6 col-md-3">
                    <h4 class="mb-0 text-primary" id="total-cards">0</h4>
                    <small class="text-muted">総カード枚数</small>
                </div>
                <div class="col-6 col-md-3">
                    <h4 class="mb-0 text-success" id="unique-cards">0</h4>
                    <small class="text-muted">種類数</small>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <h4 class="mb-0 text-info" id="filtered-cards">0</h4>
                    <small class="text-muted">表示中</small>
                </div>
                <div class="col-6 col-md-3 mt-3 mt-md-0">
                    <h4 class="mb-0 text-warning" id="current-page-info">0</h4>
                    <small class="text-muted">ページ</small>
                </div>
            </div>
        </div>

        <!-- Filter section -->
        <div class="filter-section">
            <div class="row g-2">
                <div class="col-md-4">
                    <input type="text" class="form-control" id="search-input" placeholder="カード名で検索...">
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="rarity-filter">
                        <option value="">すべてのレアリティ</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <select class="form-select" id="tag-filter">
                        <option value="">すべてのタグ</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <button class="btn btn-outline-secondary w-100" id="clear-filters">
                        <i class="bi bi-x-circle"></i> クリア
                    </button>
                </div>
            </div>
            <div class="row g-2 mt-2">
                <div class="col-md-12">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-unowned-cards" role="switch">
                        <label class="form-check-label" for="show-unowned-cards">
                            <i class="bi bi-eye"></i> 未所持カードを表示（全カードデータから）
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls bar -->
        <div class="controls-bar">
            <div class="view-controls">
                <!-- Display count -->
                <div class="input-group" style="width: auto;">
                    <label class="input-group-text" for="items-per-page">表示件数</label>
                    <select class="form-select" id="items-per-page" style="width: auto;">
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="30">30</option>
                        <option value="50" selected>50</option>
                        <option value="100">100</option>
                    </select>
                </div>

                <!-- Grid size selector -->
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn" data-size="small" title="小">
                        <i class="bi bi-square" style="font-size: 0.7rem;"></i> 小
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn active" data-size="medium" title="中">
                        <i class="bi bi-square" style="font-size: 0.9rem;"></i> 中
                    </button>
                    <button type="button" class="btn btn-outline-secondary btn-sm size-btn" data-size="large" title="大">
                        <i class="bi bi-square" style="font-size: 1.1rem;"></i> 大
                    </button>
                </div>

                <!-- Sort selector -->
                <div class="input-group" style="width: auto;">
                    <label class="input-group-text" for="sort-select">並び替え</label>
                    <select class="form-select" id="sort-select" style="width: auto;">
                        <option value="name-asc">名前 (昇順)</option>
                        <option value="name-desc">名前 (降順)</option>
                        <option value="code-asc">型番 (昇順)</option>
                        <option value="code-desc">型番 (降順)</option>
                        <option value="quantity-desc" selected>枚数 (多い順)</option>
                        <option value="quantity-asc">枚数 (少ない順)</option>
                        <option value="rarity-asc">レアリティ (昇順)</option>
                        <option value="rarity-desc">レアリティ (降順)</option>
                    </select>
                </div>

                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-warning btn-sm" id="deck-manager-btn">
                        <i class="bi bi-stack"></i> デッキ管理
                    </button>
                    <button class="btn btn-primary btn-sm" onclick="window.location.href='card_list.html'">
                        <i class="bi bi-arrow-left"></i> リスト表示に戻る
                    </button>
                </div>
            </div>
        </div>

        <!-- Pagination top -->
        <div class="pagination-controls" id="pagination-top"></div>

        <!-- Card grid -->
        <div class="card-grid size-medium" id="card-grid">
            <!-- Cards will be rendered here -->
        </div>

        <!-- Pagination bottom -->
        <div class="pagination-controls" id="pagination-bottom"></div>
    </div>

    <!-- Card Edit Side Panel -->
    <div class="edit-panel-overlay" id="editPanelOverlay"></div>
    <div class="edit-panel" id="editPanel">
        <div class="edit-panel-content">
            <!-- Left side: Card Image -->
            <div class="edit-panel-left">
                <img id="panelCardImage" src="" alt="Card Image">
            </div>

            <!-- Right side: Edit Form -->
            <div class="edit-panel-right">
                <div class="edit-panel-header">
                    <h3 id="panelCardName">カード編集</h3>
                    <button class="edit-panel-close" id="closePanelBtn">
                        <i class="bi bi-x"></i>
                    </button>
                </div>

                <form class="edit-panel-form">
                    <div class="mb-3">
                        <label for="panelQuantity" class="form-label">
                            <i class="bi bi-stack"></i> 枚数
                        </label>
                        <input type="number" class="form-control" id="panelQuantity" min="0">
                    </div>

                    <div class="mb-3">
                        <label for="panelTags" class="form-label">
                            <i class="bi bi-tags"></i> タグ（カンマ区切り）
                        </label>
                        <input type="text" class="form-control" id="panelTags" placeholder="デッキ1, お気に入り">
                    </div>

                    <div class="mb-3">
                        <label class="form-label">
                            <i class="bi bi-upc"></i> 型番
                        </label>
                        <p class="form-control-plaintext" id="panelCode">-</p>
                    </div>

                    <div class="mb-3">
                        <label class="form-label">
                            <i class="bi bi-gem"></i> レアリティ
                        </label>
                        <p class="form-control-plaintext" id="panelRarity">-</p>
                    </div>

                    <div class="edit-panel-actions">
                        <button type="button" class="btn btn-danger" id="deletePanelCardBtn">
                            <i class="bi bi-trash"></i> 削除
                        </button>
                        <button type="button" class="btn btn-primary" id="savePanelCardBtn">
                            <i class="bi bi-save"></i> 保存
                        </button>
                    </div>

                    <!-- Deck usage section -->
                    <div id="deckUsageSection" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #dee2e6;">
                        <label class="form-label">
                            <i class="bi bi-collection"></i> デッキ使用状況
                        </label>
                        <div id="deckUsageList" style="font-size: 0.9rem; color: #495057;">
                            <!-- Deck usage will be displayed here -->
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Deck List Side Panel -->
    <div class="deck-list-panel" id="deckListPanel">
        <div class="deck-list-header">
            <h4><i class="bi bi-stack"></i> デッキ管理</h4>
            <button class="deck-list-close" id="closeDeckListBtn">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="deck-list-content">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h6 class="mb-0">デッキ一覧</h6>
                <button class="btn btn-primary btn-sm" id="create-new-deck-btn">
                    <i class="bi bi-plus-circle"></i> 新規デッキ作成
                </button>
            </div>
            <div id="deck-list-container">
                <!-- Deck list will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Deck Builder Side Panel -->
    <div class="deck-builder-panel" id="deckBuilderPanel">
        <div class="deck-builder-header">
            <h4 id="deckBuilderTitle">デッキ編集</h4>
            <button class="deck-builder-close" id="closeDeckBuilderBtn">
                <i class="bi bi-x"></i>
            </button>
        </div>
        <div class="deck-builder-content">
            <!-- Deck Info -->
            <div class="deck-info-section">
                <div class="mb-2">
                    <label class="form-label small fw-bold">デッキ名</label>
                    <input type="text" class="form-control form-control-sm" id="deckName" placeholder="デッキ名を入力">
                </div>
                <div class="mb-3">
                    <label class="form-label small fw-bold">メモ</label>
                    <textarea class="form-control form-control-sm" id="deckMemo" rows="2" placeholder="メモを入力"></textarea>
                </div>
            </div>

            <!-- Deck Cards -->
            <div class="deck-cards-section">
                <!-- Main Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">メインデッキ (<span id="mainDeckCount">0</span>/1~60)</h6>
                    </div>
                    <div class="deck-drop-zone" id="mainDeckDropZone" data-deck-type="main">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">メインデッキ (40~60枚)</p>
                        </div>
                        <div id="mainDeckCardsList"></div>
                    </div>
                </div>

                <!-- Extra Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">エクストラデッキ (<span id="extraDeckCount">0</span>/0~15)</h6>
                    </div>
                    <div class="deck-drop-zone" id="extraDeckDropZone" data-deck-type="extra">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">エクストラデッキ (0~15枚)</p>
                        </div>
                        <div id="extraDeckCardsList"></div>
                    </div>
                </div>

                <!-- Side Deck -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">サイドデッキ (<span id="sideDeckCount">0</span>/0~15)</h6>
                    </div>
                    <div class="deck-drop-zone" id="sideDeckDropZone" data-deck-type="side">
                        <div class="deck-drop-placeholder">
                            <i class="bi bi-plus-circle"></i>
                            <p class="small mb-0">サイドデッキ (0~15枚)</p>
                        </div>
                        <div id="sideDeckCardsList"></div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="deck-builder-actions">
                <button class="btn btn-success w-100" id="saveDeckBtn">
                    <i class="bi bi-save"></i> デッキを保存
                </button>
                <button class="btn btn-outline-danger w-100 mt-2" id="deleteDeckBtn">
                    <i class="bi bi-trash"></i> デッキを削除
                </button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { getFirestore, collection, getDocs, doc, updateDoc, deleteDoc, addDoc, setDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAOYKalLUb2hbghrjQUS8AWzxpLExBT7aU",
            authDomain: "ygoh-9bcf6.firebaseapp.com",
            projectId: "ygoh-9bcf6",
            storageBucket: "ygoh-9bcf6.firebasestorage.app",
            messagingSenderId: "515041224138",
            appId: "1:515041224138:web:8de47b38ed9cc1bb8afd37",
            measurementId: "G-ZGSRE8MHZ2"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // State
        let collectionCards = [];
        let wishlistCards = [];
        let allCards = [];
        let filteredCards = [];
        let cardDetailsMap = new Map();
        let cardReadingMap = new Map(); // Map for hiragana -> card names
        let currentUser = null;
        let currentPage = 1;
        let itemsPerPage = 50;
        let currentGridSize = 'medium';
        let currentSort = 'quantity-desc';
        let currentListType = 'collection'; // 'collection' or 'wishlist'
        let currentEditingCard = null;
        let currentRenderingId = 0; // To prevent duplicate images when rapidly changing pages

        // Deck system state
        let decks = []; // All user's decks
        let currentDeck = null; // Currently editing deck
        const deckListPanel = document.getElementById('deckListPanel');
        let draggedCard = null; // Card being dragged from gallery
        let draggedDeckCard = null; // Deck card being dragged (for moving between decks or removing)

        // Load card reading data
        const loadCardData = async () => {
            try {
                const response = await fetch('yugioh_cards_master.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');

                // Parse CSV and build card details map
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(',');
                    const cardName = values[1]?.replace(/"/g, '');
                    const cardId = values[0]?.replace(/"/g, '');
                    const cardReading = values[2]?.replace(/"/g, '');

                    if (cardName && cardId) {
                        cardDetailsMap.set(cardName, {
                            cardId: cardId,
                            reading: cardReading,
                            cardType: values[3]?.replace(/"/g, ''),
                            level: values[4]?.replace(/"/g, ''),
                            attribute: values[5]?.replace(/"/g, ''),
                            race: values[6]?.replace(/"/g, ''),
                            attack: values[7]?.replace(/"/g, ''),
                            defense: values[8]?.replace(/"/g, ''),
                            cardText: values[9]?.replace(/"/g, '')
                        });

                        // Build reading map for hiragana search
                        if (cardReading) {
                            const readingKey = cardReading.toLowerCase();

                            // Store multiple cards with same reading
                            if (!cardReadingMap.has(readingKey)) {
                                cardReadingMap.set(readingKey, []);
                            }
                            cardReadingMap.get(readingKey).push(cardName);

                            // Also store hiragana version of the reading if it's in katakana
                            const hiraganaReading = readingKey.replace(/[\u30A1-\u30F6]/g, function(match) {
                                const code = match.charCodeAt(0) - 0x60;
                                return String.fromCharCode(code);
                            });

                            if (hiraganaReading !== readingKey) {
                                if (!cardReadingMap.has(hiraganaReading)) {
                                    cardReadingMap.set(hiraganaReading, []);
                                }
                                cardReadingMap.get(hiraganaReading).push(cardName);
                            }
                        }
                    }
                }

                console.log(`Loaded ${cardReadingMap.size} card readings and ${cardDetailsMap.size} card details from CSV`);
            } catch (error) {
                console.error('Error loading card data:', error);
            }
        };

        // Get card image URL (with cache support)
        const getCardImageUrl = async (cardName) => {
            const details = cardDetailsMap.get(cardName);
            if (!details?.cardId) {
                return null;
            }

            const cardId = details.cardId;

            try {
                // Check cache first
                const cachedImage = await imageCacheManager.getImage(cardId);
                if (cachedImage) {
                    console.log(`Using cached image for: ${cardName} (ID: ${cardId})`);
                    return cachedImage;
                }

                // Cache miss - fetch from proxy and cache it
                console.log(`Fetching image for: ${cardName} (ID: ${cardId})`);
                const imageData = await imageCacheManager.fetchAndCache(cardId);
                return imageData;
            } catch (error) {
                console.error(`Error loading image for ${cardName}:`, error);
                // Fallback to direct URL (will likely fail due to CORS, but worth trying)
                return `https://www.db.yugioh-card.com/yugiohdb/card_image.action?cid=${cardId}&request_locale=ja`;
            }
        };

        // Load user's card collection and wishlist
        const loadAllData = async (userId) => {
            showLoading(true);
            try {
                // Load collection cards from subcollection: users/{userId}/cards
                const collectionRef = collection(db, 'users', userId, 'cards');
                const collectionSnapshot = await getDocs(collectionRef);
                collectionCards = collectionSnapshot.docs.map(doc => ({
                    id: doc.id,
                    data: doc.data()
                }));

                // Load wishlist cards from subcollection: users/{userId}/wishlist
                const wishlistRef = collection(db, 'users', userId, 'wishlist');
                const wishlistSnapshot = await getDocs(wishlistRef);
                wishlistCards = wishlistSnapshot.docs.map(doc => ({
                    id: doc.id,
                    data: doc.data()
                }));

                // Set initial data based on current list type
                switchListType(currentListType);
            } catch (error) {
                console.error('Error loading data:', error);
                alert('カードの読み込みに失敗しました。');
            } finally {
                showLoading(false);
            }
        };

        // Switch between collection and wishlist
        const switchListType = (listType) => {
            currentListType = listType;
            allCards = listType === 'collection' ? collectionCards : wishlistCards;

            // Save to localStorage
            localStorage.setItem('galleryListType', listType);

            // Update tab active state
            document.querySelectorAll('.nav-link').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`${listType}-tab`).classList.add('active');

            // Reset to page 1 when switching
            currentPage = 1;

            applyFilters();
            updateStats();
            renderCards();
            populateFilterOptions();
        };

        // Show/hide loading overlay
        const showLoading = (show) => {
            const overlay = document.getElementById('loading-overlay');
            if (show) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        };

        // Normalize text for search (convert katakana to hiragana, lowercase)
        const normalizeForSearch = (text) => {
            if (!text) return '';

            // Convert to lowercase
            text = text.toLowerCase();

            // Convert katakana to hiragana
            text = text.replace(/[ァ-ヶ]/g, (match) => {
                const code = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(code);
            });

            // Remove middle dots (・) for more flexible search
            text = text.replace(/・/g, '');

            return text;
        };

        // Apply filters
        const applyFilters = () => {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            const rarityFilter = document.getElementById('rarity-filter').value;
            const tagFilter = document.getElementById('tag-filter').value;
            const showUnowned = document.getElementById('show-unowned-cards').checked;

            // Get possible card names from hiragana reading
            let possibleCardNames = [];
            if (searchTerm) {
                // Check if the search term matches any reading in our map
                if (cardReadingMap.has(searchTerm)) {
                    possibleCardNames = cardReadingMap.get(searchTerm);
                }

                // Also check for partial matches in readings
                for (const [reading, cards] of cardReadingMap) {
                    if (reading.includes(searchTerm)) {
                        possibleCardNames.push(...cards);
                    }
                }
            }

            // Normalize search term for card name matching
            const normalizedSearchTerm = normalizeForSearch(searchTerm);

            // Filter owned cards
            filteredCards = allCards.filter(card => {
                const cardName = card.data['名前'] || '';

                // Check if matches search
                let matchesSearch = !searchTerm;
                if (searchTerm) {
                    // Direct name match (normalized)
                    if (normalizeForSearch(cardName).includes(normalizedSearchTerm)) {
                        matchesSearch = true;
                    }
                    // Hiragana reading match
                    else if (possibleCardNames.includes(cardName)) {
                        matchesSearch = true;
                    }
                }

                const matchesRarity = !rarityFilter || card.data['レアリティ'] === rarityFilter;
                const matchesTag = !tagFilter || (card.data.tags && card.data.tags.includes(tagFilter));

                return matchesSearch && matchesRarity && matchesTag;
            });

            // Add unowned cards if checkbox is checked
            if (showUnowned) {
                // Get owned card names
                const ownedCardNames = new Set(allCards.map(card => card.data['名前']));

                // Create unowned cards from cardDetailsMap
                const unownedCards = [];
                for (const [cardName, details] of cardDetailsMap) {
                    if (!ownedCardNames.has(cardName)) {
                        // Apply filters to unowned cards too
                        let matchesSearch = !searchTerm;
                        if (searchTerm) {
                            if (normalizeForSearch(cardName).includes(normalizedSearchTerm)) {
                                matchesSearch = true;
                            } else if (possibleCardNames.includes(cardName)) {
                                matchesSearch = true;
                            }
                        }

                        // Note: unowned cards don't have rarity or tags, so skip those filters
                        if (matchesSearch && !rarityFilter && !tagFilter) {
                            unownedCards.push({
                                id: 'unowned-' + details.cardId,
                                data: {
                                    '名前': cardName,
                                    '型番': details.cardId || '',
                                    'レアリティ': '-',
                                    '枚数': 0,
                                    'tags': [],
                                    'unowned': true
                                },
                                unowned: true
                            });
                        }
                    }
                }

                // Add unowned cards to filtered results
                filteredCards = [...filteredCards, ...unownedCards];
            }

            sortCards();
            currentPage = 1;
        };

        // Sort cards
        const sortCards = () => {
            const [field, direction] = currentSort.split('-');

            filteredCards.sort((a, b) => {
                let valA, valB;

                switch (field) {
                    case 'name':
                        valA = a.data['名前'] || '';
                        valB = b.data['名前'] || '';
                        break;
                    case 'code':
                        valA = a.data['型番'] || '';
                        valB = b.data['型番'] || '';
                        break;
                    case 'quantity':
                        valA = parseInt(a.data['枚数']) || 0;
                        valB = parseInt(b.data['枚数']) || 0;
                        break;
                    case 'rarity':
                        valA = a.data['レアリティ'] || '';
                        valB = b.data['レアリティ'] || '';
                        break;
                    default:
                        return 0;
                }

                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (direction === 'asc') {
                    return valA > valB ? 1 : valA < valB ? -1 : 0;
                } else {
                    return valA < valB ? 1 : valA > valB ? -1 : 0;
                }
            });
        };

        // Handle drag start for cards
        window.handleDragStart = (event, index) => {
            const startIndex = (currentPage - 1) * itemsPerPage;
            const cardIndex = startIndex + index;
            draggedCard = filteredCards[cardIndex];
            event.dataTransfer.effectAllowed = 'copy';
            event.target.classList.add('dragging');
        };

        // Render cards (with async image loading)
        const renderCards = async () => {
            // Increment rendering ID to invalidate previous async operations
            currentRenderingId++;
            const thisRenderingId = currentRenderingId;

            const grid = document.getElementById('card-grid');
            grid.className = `card-grid size-${currentGridSize}`;

            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageCards = filteredCards.slice(startIndex, endIndex);

            if (pageCards.length === 0) {
                grid.innerHTML = `
                    <div class="text-center py-5 w-100">
                        <i class="bi bi-inbox" style="font-size: 4rem; color: #ccc;"></i>
                        <p class="text-muted mt-3">該当するカードはありません。</p>
                    </div>
                `;
            } else {
                // First render with placeholders
                grid.innerHTML = pageCards.map((card, index) => {
                    const tags = (card.data.tags || []).map(tag =>
                        `<span class="badge bg-secondary">${escapeHtml(tag)}</span>`
                    ).join(' ');

                    const isUnowned = card.unowned || card.data.unowned;
                    const unownedClass = isUnowned ? ' unowned' : '';
                    const unownedBadge = isUnowned ? '<span class="unowned-badge">未所持</span>' : '';

                    // Calculate stock display with deck usage
                    let stockBadge = '';
                    if (!isUnowned) {
                        const totalStock = card.data['枚数'] || 0;
                        const { totalUsed } = getCardUsageInDecks(card.id);
                        const availableStock = totalStock - totalUsed;
                        stockBadge = `<span class="stock-badge">在庫 ${availableStock}-${totalUsed}(${totalStock})枚</span>`;
                    }

                    const onclickAttr = isUnowned ? '' : `onclick="openCardEditModal('${card.id}')"`;
                    const draggableAttr = isUnowned ? '' : `draggable="true" ondragstart="handleDragStart(event, ${index})" class="draggable"`;

                    return `
                        <div class="card-item${unownedClass}" ${onclickAttr} ${draggableAttr} data-card-index="${index}">
                            <div class="card-image-container" id="card-img-container-${index}" data-rendering-id="${thisRenderingId}">
                                ${stockBadge}
                                ${unownedBadge}
                                <i class="bi bi-card-image card-image-placeholder"></i>
                            </div>
                            <div class="card-info">
                                <div class="card-name">${escapeHtml(card.data['名前'])}</div>
                                <div class="card-code">${escapeHtml(card.data['型番'])}</div>
                                <div class="card-rarity">
                                    <span class="badge bg-info">${escapeHtml(card.data['レアリティ'])}</span>
                                </div>
                                <div class="card-tags">
                                    ${tags || '<span class="text-muted" style="font-size: 0.7rem;">タグなし</span>'}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // Then load images asynchronously
                pageCards.forEach(async (card, index) => {
                    try {
                        const imageUrl = await getCardImageUrl(card.data['名前']);
                        const container = document.getElementById(`card-img-container-${index}`);

                        // Check if this rendering is still valid (page hasn't changed)
                        if (!container || parseInt(container.dataset.renderingId) !== thisRenderingId) {
                            return; // Skip adding image if page has changed
                        }

                        if (imageUrl) {
                            // Create image element
                            const img = document.createElement('img');
                            img.src = imageUrl;
                            img.alt = card.data['名前'];
                            img.loading = 'lazy';

                            // Handle image error
                            img.onerror = function() {
                                // Save parent reference before clearing
                                const parent = this.parentElement;
                                if (!parent) return;

                                // Keep stock badge and show placeholder
                                const stockBadge = parent.querySelector('.stock-badge');
                                parent.innerHTML = '';
                                if (stockBadge) {
                                    parent.appendChild(stockBadge);
                                }
                                const placeholder = document.createElement('i');
                                placeholder.className = 'bi bi-card-image card-image-placeholder';
                                parent.appendChild(placeholder);
                            };

                            // Clear placeholder and add image (keep stock badge)
                            const stockBadge = container.querySelector('.stock-badge');
                            const placeholder = container.querySelector('.card-image-placeholder');
                            if (placeholder) {
                                placeholder.remove();
                            }
                            container.appendChild(img);
                        }
                    } catch (error) {
                        console.error(`Failed to load image for ${card.data['名前']}:`, error);
                    }
                });
            }

            updatePagination();
            updateStats();
        };

        // Update pagination
        const updatePagination = () => {
            const totalPages = Math.ceil(filteredCards.length / itemsPerPage);
            const paginationHtml = `
                <button class="btn btn-outline-primary btn-sm" ${currentPage <= 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">
                    <i class="bi bi-chevron-left"></i> 前へ
                </button>
                <span class="mx-3">
                    <strong>${currentPage}</strong> / ${totalPages} ページ
                </span>
                <button class="btn btn-outline-primary btn-sm" ${currentPage >= totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">
                    次へ <i class="bi bi-chevron-right"></i>
                </button>
            `;

            document.getElementById('pagination-top').innerHTML = paginationHtml;
            document.getElementById('pagination-bottom').innerHTML = paginationHtml;
        };

        // Update stats
        const updateStats = () => {
            const totalQuantity = allCards.reduce((sum, card) => sum + (parseInt(card.data['枚数']) || 0), 0);
            const uniqueCount = allCards.length;
            const filteredCount = filteredCards.length;
            const totalPages = Math.ceil(filteredCards.length / itemsPerPage);

            document.getElementById('total-cards').textContent = totalQuantity;
            document.getElementById('unique-cards').textContent = uniqueCount;
            document.getElementById('filtered-cards').textContent = filteredCount;
            document.getElementById('current-page-info').textContent = `${currentPage}/${totalPages}`;
        };

        // Populate filter options
        const populateFilterOptions = () => {
            // Rarities
            const rarities = [...new Set(allCards.map(card => card.data['レアリティ']).filter(Boolean))].sort();
            const raritySelect = document.getElementById('rarity-filter');
            raritySelect.innerHTML = '<option value="">すべてのレアリティ</option>' +
                rarities.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');

            // Tags
            const tags = [...new Set(allCards.flatMap(card => card.data.tags || []))].sort();
            const tagSelect = document.getElementById('tag-filter');
            tagSelect.innerHTML = '<option value="">すべてのタグ</option>' +
                tags.map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join('');
        };

        // Utility functions
        const escapeHtml = (str) => {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        };

        // Global functions
        window.changePage = (page) => {
            currentPage = page;
            renderCards();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        window.openCardEditModal = async (cardId) => {
            // Don't open edit modal if deck builder is active
            if (currentDeck) return;

            // Find the card in current list
            const card = allCards.find(c => c.id === cardId);
            if (!card) return;

            currentEditingCard = card;

            // Populate panel with card data
            document.getElementById('panelCardName').textContent = card.data['名前'];
            document.getElementById('panelQuantity').value = card.data['枚数'] || 0;
            document.getElementById('panelTags').value = (card.data.tags || []).join(', ');
            document.getElementById('panelCode').textContent = card.data['型番'] || '-';
            document.getElementById('panelRarity').textContent = card.data['レアリティ'] || '-';

            // Load card image
            const imageUrl = await getCardImageUrl(card.data['名前']);
            const panelImage = document.getElementById('panelCardImage');
            if (imageUrl) {
                panelImage.src = imageUrl;
                panelImage.style.display = 'block';
            } else {
                panelImage.style.display = 'none';
            }

            // Display deck usage
            const { usageMap, totalUsed } = getCardUsageInDecks(cardId);
            const deckUsageSection = document.getElementById('deckUsageSection');
            const deckUsageList = document.getElementById('deckUsageList');

            if (totalUsed > 0) {
                let usageHTML = '';
                for (const [deckName, count] of Object.entries(usageMap)) {
                    usageHTML += `<div style="margin-bottom: 0.3rem;">・${deckName}: ${count}枚</div>`;
                }
                deckUsageList.innerHTML = usageHTML;
                deckUsageSection.style.display = 'block';
            } else {
                deckUsageSection.style.display = 'none';
            }

            // Show panel
            document.getElementById('editPanelOverlay').classList.add('show');
            document.getElementById('editPanel').classList.add('show');
        };

        // Close panel function
        const closeEditPanel = () => {
            document.getElementById('editPanelOverlay').classList.remove('show');
            document.getElementById('editPanel').classList.remove('show');
        };

        // Event listeners
        document.getElementById('items-per-page').addEventListener('change', (e) => {
            itemsPerPage = parseInt(e.target.value);
            currentPage = 1;
            renderCards();
        });

        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                e.target.closest('button').classList.add('active');
                currentGridSize = e.target.closest('button').dataset.size;
                localStorage.setItem('galleryGridSize', currentGridSize);
                renderCards();
            });
        });

        document.getElementById('sort-select').addEventListener('change', (e) => {
            currentSort = e.target.value;
            applyFilters();
            renderCards();
        });

        document.getElementById('search-input').addEventListener('input', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('rarity-filter').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('tag-filter').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        document.getElementById('clear-filters').addEventListener('click', () => {
            document.getElementById('search-input').value = '';
            document.getElementById('rarity-filter').value = '';
            document.getElementById('tag-filter').value = '';
            applyFilters();
            renderCards();
        });

        document.getElementById('show-unowned-cards').addEventListener('change', () => {
            applyFilters();
            renderCards();
        });

        // Tab click event listeners
        document.getElementById('collection-tab').addEventListener('click', () => {
            switchListType('collection');
        });

        document.getElementById('wishlist-tab').addEventListener('click', () => {
            switchListType('wishlist');
        });

        // Close panel button
        document.getElementById('closePanelBtn').addEventListener('click', closeEditPanel);
        document.getElementById('editPanelOverlay').addEventListener('click', closeEditPanel);

        // Panel save button
        document.getElementById('savePanelCardBtn').addEventListener('click', async () => {
            if (!currentEditingCard || !currentUser) return;

            const newQuantity = parseInt(document.getElementById('panelQuantity').value) || 0;
            const tagsInput = document.getElementById('panelTags').value;
            const newTags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];

            try {
                // Determine collection path based on current list type
                const collectionPath = currentListType === 'collection' ? 'cards' : 'wishlist';
                const cardRef = doc(db, 'users', currentUser.uid, collectionPath, currentEditingCard.id);

                await updateDoc(cardRef, {
                    '枚数': newQuantity,
                    'tags': newTags
                });

                // Update local data
                currentEditingCard.data['枚数'] = newQuantity;
                currentEditingCard.data.tags = newTags;

                // Close panel
                closeEditPanel();

                // Refresh display
                applyFilters();
                renderCards();

                alert('カード情報を更新しました。');
            } catch (error) {
                console.error('Error updating card:', error);
                alert('カード情報の更新に失敗しました。');
            }
        });

        // Panel delete button
        document.getElementById('deletePanelCardBtn').addEventListener('click', async () => {
            if (!currentEditingCard || !currentUser) return;

            if (!confirm(`「${currentEditingCard.data['名前']}」を削除してもよろしいですか？`)) {
                return;
            }

            try {
                // Determine collection path based on current list type
                const collectionPath = currentListType === 'collection' ? 'cards' : 'wishlist';
                const cardRef = doc(db, 'users', currentUser.uid, collectionPath, currentEditingCard.id);

                await deleteDoc(cardRef);

                // Remove from local data
                if (currentListType === 'collection') {
                    collectionCards = collectionCards.filter(c => c.id !== currentEditingCard.id);
                } else {
                    wishlistCards = wishlistCards.filter(c => c.id !== currentEditingCard.id);
                }
                allCards = currentListType === 'collection' ? collectionCards : wishlistCards;

                // Close panel
                closeEditPanel();

                // Refresh display
                applyFilters();
                renderCards();
                populateFilterOptions();

                alert('カードを削除しました。');
            } catch (error) {
                console.error('Error deleting card:', error);
                alert('カードの削除に失敗しました。');
            }
        });

        // ==================== DECK SYSTEM ====================

        // Count card usage across all decks
        const getCardUsageInDecks = (cardId) => {
            const usageMap = {}; // { deckName: count }
            let totalUsed = 0;

            decks.forEach(deck => {
                let deckTotal = 0;

                // Check main deck
                if (deck.mainDeck) {
                    const mainCard = deck.mainDeck.find(c => c.cardId === cardId);
                    if (mainCard) deckTotal += mainCard.quantity;
                }

                // Check extra deck
                if (deck.extraDeck) {
                    const extraCard = deck.extraDeck.find(c => c.cardId === cardId);
                    if (extraCard) deckTotal += extraCard.quantity;
                }

                // Check side deck
                if (deck.sideDeck) {
                    const sideCard = deck.sideDeck.find(c => c.cardId === cardId);
                    if (sideCard) deckTotal += sideCard.quantity;
                }

                if (deckTotal > 0) {
                    usageMap[deck.name || '無題のデッキ'] = deckTotal;
                    totalUsed += deckTotal;
                }
            });

            return { usageMap, totalUsed };
        };

        // Load all decks from Firestore
        const loadDecks = async () => {
            if (!currentUser) return;
            try {
                const decksRef = collection(db, 'users', currentUser.uid, 'decks');
                const snapshot = await getDocs(decksRef);
                decks = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                console.log(`Loaded ${decks.length} decks`);
            } catch (error) {
                console.error('Error loading decks:', error);
            }
        };

        // Save deck to Firestore
        const saveDeck = async () => {
            if (!currentUser || !currentDeck) return;

            const deckData = {
                name: document.getElementById('deckName').value || '無題のデッキ',
                memo: document.getElementById('deckMemo').value || '',
                mainDeck: currentDeck.mainDeck || [],
                extraDeck: currentDeck.extraDeck || [],
                sideDeck: currentDeck.sideDeck || [],
                updatedAt: new Date().toISOString()
            };

            // Validate deck counts
            const mainCount = deckData.mainDeck.reduce((sum, c) => sum + c.quantity, 0);
            const extraCount = deckData.extraDeck.reduce((sum, c) => sum + c.quantity, 0);
            const sideCount = deckData.sideDeck.reduce((sum, c) => sum + c.quantity, 0);

            if (mainCount < 1 || mainCount > 60) {
                alert(`メインデッキは1~60枚である必要があります。\n現在: ${mainCount}枚`);
                return;
            }
            if (extraCount > 15) {
                alert(`エクストラデッキは0~15枚である必要があります。\n現在: ${extraCount}枚`);
                return;
            }
            if (sideCount > 15) {
                alert(`サイドデッキは0~15枚である必要があります。\n現在: ${sideCount}枚`);
                return;
            }

            try {
                if (currentDeck.id) {
                    // Update existing deck
                    const deckRef = doc(db, 'users', currentUser.uid, 'decks', currentDeck.id);
                    await updateDoc(deckRef, deckData);
                    alert('デッキを保存しました');
                } else {
                    // Create new deck
                    deckData.createdAt = new Date().toISOString();
                    const decksRef = collection(db, 'users', currentUser.uid, 'decks');
                    const docRef = await addDoc(decksRef, deckData);
                    currentDeck.id = docRef.id;
                    alert('デッキを作成しました');
                }
                await loadDecks();
                renderDeckList();
            } catch (error) {
                console.error('Error saving deck:', error);
                alert('デッキの保存に失敗しました');
            }
        };

        // Delete deck
        const deleteDeck = async () => {
            if (!currentUser || !currentDeck || !currentDeck.id) return;

            if (!confirm('このデッキを削除しますか？')) return;

            try {
                const deckRef = doc(db, 'users', currentUser.uid, 'decks', currentDeck.id);
                await deleteDoc(deckRef);
                alert('デッキを削除しました');
                closeDeckBuilder();
                await loadDecks();
                renderDeckList();
            } catch (error) {
                console.error('Error deleting deck:', error);
                alert('デッキの削除に失敗しました');
            }
        };

        // Open deck list panel
        const openDeckList = () => {
            deckListPanel.classList.add('active');
        };

        // Close deck list panel
        const closeDeckList = () => {
            deckListPanel.classList.remove('active');
        };

        // Open deck builder panel
        const openDeckBuilder = async (deck = null) => {
            currentDeck = deck || { mainDeck: [], extraDeck: [], sideDeck: [] };

            document.getElementById('deckName').value = currentDeck.name || '';
            document.getElementById('deckMemo').value = currentDeck.memo || '';
            document.getElementById('deckBuilderTitle').textContent = deck ? 'デッキ編集' : '新規デッキ';

            await renderDeckCards();

            document.getElementById('deckBuilderPanel').classList.add('active');
            document.querySelector('.card-grid').classList.add('deck-builder-open');

            // Hide delete button for new decks
            document.getElementById('deleteDeckBtn').style.display = deck && deck.id ? 'block' : 'none';
        };

        // Close deck builder panel
        const closeDeckBuilder = () => {
            document.getElementById('deckBuilderPanel').classList.remove('active');
            document.querySelector('.card-grid').classList.remove('deck-builder-open');
            currentDeck = null;
        };

        // Render deck list in modal
        const renderDeckList = () => {
            const container = document.getElementById('deck-list-container');

            if (decks.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-4">
                        <i class="bi bi-inbox" style="font-size: 3rem; color: #ccc;"></i>
                        <p class="text-muted mt-2">デッキがありません</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = decks.map(deck => {
                const mainCount = deck.mainDeck ? deck.mainDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const extraCount = deck.extraDeck ? deck.extraDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const sideCount = deck.sideDeck ? deck.sideDeck.reduce((sum, c) => sum + c.quantity, 0) : 0;
                const cardCount = mainCount + extraCount + sideCount;
                const cardTypes = (deck.mainDeck?.length || 0) + (deck.extraDeck?.length || 0) + (deck.sideDeck?.length || 0);

                return `
                    <div class="deck-list-item" onclick="editDeck('${deck.id}')">
                        <div class="deck-list-item-header">
                            <div class="deck-list-item-name">${escapeHtml(deck.name || '無題')}</div>
                            <div class="deck-list-item-actions">
                                <button class="btn btn-sm btn-outline-primary" onclick="event.stopPropagation(); editDeck('${deck.id}')">
                                    <i class="bi bi-pencil"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger" onclick="event.stopPropagation(); deleteDeckFromList('${deck.id}')">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>
                        </div>
                        ${deck.memo ? `<div class="deck-list-item-memo">${escapeHtml(deck.memo)}</div>` : ''}
                        <div class="deck-list-item-stats">
                            <span><i class="bi bi-collection"></i> ${cardCount}枚</span>
                            <span><i class="bi bi-card-list"></i> ${cardTypes}種</span>
                            <span><i class="bi bi-clock"></i> ${new Date(deck.updatedAt || deck.createdAt).toLocaleDateString('ja-JP')}</span>
                        </div>
                    </div>
                `;
            }).join('');
        };

        // Edit deck (called from deck list)
        window.editDeck = (deckId) => {
            const deck = decks.find(d => d.id === deckId);
            if (deck) {
                closeDeckList();
                openDeckBuilder(deck);
            }
        };

        // Delete deck from list
        window.deleteDeckFromList = async (deckId) => {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return;

            if (!confirm(`「${deck.name || '無題'}」を削除してもよろしいですか？`)) {
                return;
            }

            try {
                if (!currentUser) return;

                const deckRef = doc(db, 'users', currentUser.uid, 'decks', deckId);
                await deleteDoc(deckRef);

                // Remove from local array
                decks = decks.filter(d => d.id !== deckId);
                renderDeckList();

                alert('デッキを削除しました');
            } catch (error) {
                console.error('Error deleting deck:', error);
                alert('デッキの削除に失敗しました');
            }
        };

        // Render cards in deck builder
        const renderDeckCards = async () => {
            if (!currentDeck) return;

            // Helper function to render a deck section
            const renderDeckSection = async (deckType, cards, containerId, countId) => {
                const container = document.getElementById(containerId);
                const placeholder = document.querySelector(`#${containerId.replace('CardsList', 'DropZone')} .deck-drop-placeholder`);
                const count = cards.reduce((sum, c) => sum + c.quantity, 0);

                document.getElementById(countId).textContent = count;

                if (cards.length === 0) {
                    container.innerHTML = '';
                    if (placeholder) placeholder.style.display = 'block';
                    return;
                }

                if (placeholder) placeholder.style.display = 'none';

                // First render placeholder cards in grid (repeat each card by its quantity)
                container.innerHTML = `<div class="deck-cards-grid">` + cards.flatMap((deckCard, index) => {
                    return Array(deckCard.quantity).fill(null).map((_, copyIndex) => {
                        return `
                        <div class="deck-card-item" data-card-index="${index}" data-copy-index="${copyIndex}" data-deck-type="${deckType}" draggable="true">
                            <div class="deck-card-image-container">
                                <img data-card-name="${escapeHtml(deckCard.name)}" alt="${escapeHtml(deckCard.name)}" style="display:none;">
                                <div class="deck-card-image-placeholder">
                                    <i class="bi bi-card-image"></i>
                                </div>
                                <div class="deck-card-rarity">${escapeHtml(deckCard.rarity || '')}</div>
                                <div class="deck-card-code">${escapeHtml(deckCard.code || '')}</div>
                            </div>
                        </div>
                    `;
                    });
                }).join('') + `</div>`;

                // Then load images asynchronously
                const grid = container.querySelector('.deck-cards-grid');
                if (grid) {
                    for (let i = 0; i < cards.length; i++) {
                        const card = cards[i];
                        const cardItems = grid.querySelectorAll(`[data-card-index="${i}"]`);

                        try {
                            const imageUrl = await getCardImageUrl(card.name);
                            if (imageUrl) {
                                // Apply the same image to all copies of this card
                                cardItems.forEach(cardItem => {
                                    const img = cardItem.querySelector('img');
                                    const placeholder = cardItem.querySelector('.deck-card-image-placeholder');
                                    img.src = imageUrl;
                                    img.style.display = 'block';
                                    placeholder.style.display = 'none';
                                });
                            }
                        } catch (error) {
                            console.error(`Failed to load image for ${card.name}:`, error);
                        }
                    }

                    // Setup drag events for deck cards
                    grid.querySelectorAll('.deck-card-item').forEach(cardItem => {
                        cardItem.addEventListener('dragstart', (e) => {
                            const cardIndex = parseInt(cardItem.dataset.cardIndex);
                            const sourceDeckType = cardItem.dataset.deckType;
                            draggedDeckCard = {
                                card: cards[cardIndex],
                                sourceDeckType: sourceDeckType
                            };
                            cardItem.classList.add('dragging');
                        });

                        cardItem.addEventListener('dragend', (e) => {
                            cardItem.classList.remove('dragging');
                        });
                    });
                }
            };

            // Render each section
            await renderDeckSection('main', currentDeck.mainDeck || [], 'mainDeckCardsList', 'mainDeckCount');
            await renderDeckSection('extra', currentDeck.extraDeck || [], 'extraDeckCardsList', 'extraDeckCount');
            await renderDeckSection('side', currentDeck.sideDeck || [], 'sideDeckCardsList', 'sideDeckCount');
        };

        // Add card to deck
        const addCardToDeck = async (cardData, deckType) => {
            if (!currentDeck) {
                alert('デッキを開いてください');
                return;
            }

            // Determine which deck to add to
            const deckKey = deckType === 'main' ? 'mainDeck' :
                          deckType === 'extra' ? 'extraDeck' : 'sideDeck';

            if (!currentDeck[deckKey]) {
                currentDeck[deckKey] = [];
            }

            // Check count limits before adding
            const currentCount = currentDeck[deckKey].reduce((sum, c) => sum + c.quantity, 0);
            const limit = deckType === 'main' ? 60 : 15;

            if (currentCount >= limit) {
                const deckName = deckType === 'main' ? 'メインデッキ' :
                               deckType === 'extra' ? 'エクストラデッキ' : 'サイドデッキ';
                alert(`${deckName}は${limit}枚までです。`);
                return;
            }

            // Check if card already exists in this deck
            const existingIndex = currentDeck[deckKey].findIndex(c => c.cardId === cardData.id);

            if (existingIndex >= 0) {
                currentDeck[deckKey][existingIndex].quantity++;
            } else {
                currentDeck[deckKey].push({
                    cardId: cardData.id,
                    name: cardData.data['名前'],
                    code: cardData.data['型番'],
                    rarity: cardData.data['レアリティ'],
                    quantity: 1
                });
            }

            await renderDeckCards();
        };

        // Remove card from deck
        const removeCardFromDeck = async (card, sourceDeckType) => {
            if (!currentDeck) return;

            const deckKey = sourceDeckType === 'main' ? 'mainDeck' :
                          sourceDeckType === 'extra' ? 'extraDeck' : 'sideDeck';

            const existingIndex = currentDeck[deckKey].findIndex(c => c.cardId === card.cardId);
            if (existingIndex !== -1) {
                if (currentDeck[deckKey][existingIndex].quantity > 1) {
                    currentDeck[deckKey][existingIndex].quantity--;
                } else {
                    currentDeck[deckKey].splice(existingIndex, 1);
                }
                await renderDeckCards();
            }
        };

        // Move card between deck sections
        const moveCardBetweenDecks = async (card, sourceDeckType, targetDeckType) => {
            if (!currentDeck || sourceDeckType === targetDeckType) return;

            // Check target deck limits first
            const targetKey = targetDeckType === 'main' ? 'mainDeck' :
                           targetDeckType === 'extra' ? 'extraDeck' : 'sideDeck';

            if (!currentDeck[targetKey]) {
                currentDeck[targetKey] = [];
            }

            const currentCount = currentDeck[targetKey].reduce((sum, c) => sum + c.quantity, 0);
            const limit = targetDeckType === 'main' ? 60 : 15;

            if (currentCount >= limit) {
                const deckName = targetDeckType === 'main' ? 'メインデッキ' :
                               targetDeckType === 'extra' ? 'エクストラデッキ' : 'サイドデッキ';
                alert(`${deckName}は${limit}枚までです。`);
                return;
            }

            // Remove from source
            const sourceKey = sourceDeckType === 'main' ? 'mainDeck' :
                           sourceDeckType === 'extra' ? 'extraDeck' : 'sideDeck';
            const existingIndex = currentDeck[sourceKey].findIndex(c => c.cardId === card.cardId);
            if (existingIndex === -1) return;

            if (currentDeck[sourceKey][existingIndex].quantity > 1) {
                currentDeck[sourceKey][existingIndex].quantity--;
            } else {
                currentDeck[sourceKey].splice(existingIndex, 1);
            }

            // Add to target deck
            const targetIndex = currentDeck[targetKey].findIndex(c => c.cardId === card.cardId);
            if (targetIndex !== -1) {
                currentDeck[targetKey][targetIndex].quantity++;
            } else {
                currentDeck[targetKey].push({
                    cardId: card.cardId,
                    name: card.name,
                    code: card.code,
                    rarity: card.rarity,
                    quantity: 1
                });
            }

            await renderDeckCards();
        };

        // Setup drag and drop
        const setupDragAndDrop = () => {
            const setupDropZone = (dropZoneId, deckType) => {
                const dropZone = document.getElementById(dropZoneId);
                if (!dropZone) return;

                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });

                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('drag-over');
                });

                dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');

                    // Handle card from gallery
                    if (draggedCard) {
                        addCardToDeck(draggedCard, deckType);
                        draggedCard = null;
                    }
                    // Handle card from deck (moving between decks)
                    else if (draggedDeckCard) {
                        await moveCardBetweenDecks(draggedDeckCard.card, draggedDeckCard.sourceDeckType, deckType);
                        draggedDeckCard = null;
                    }
                });
            };

            setupDropZone('mainDeckDropZone', 'main');
            setupDropZone('extraDeckDropZone', 'extra');
            setupDropZone('sideDeckDropZone', 'side');

            // Setup drop on panel outside (for card removal)
            const deckBuilderPanel = document.getElementById('deckBuilderPanel');
            if (deckBuilderPanel) {
                deckBuilderPanel.addEventListener('dragover', (e) => {
                    // Only allow dropping deck cards outside drop zones
                    if (draggedDeckCard && !e.target.closest('.deck-drop-zone')) {
                        e.preventDefault();
                    }
                });

                deckBuilderPanel.addEventListener('drop', async (e) => {
                    // If dropped outside drop zones, remove card
                    if (draggedDeckCard && !e.target.closest('.deck-drop-zone')) {
                        e.preventDefault();
                        await removeCardFromDeck(draggedDeckCard.card, draggedDeckCard.sourceDeckType);
                        draggedDeckCard = null;
                    }
                });
            }
        };

        // Event listeners for deck system
        document.getElementById('deck-manager-btn').addEventListener('click', async () => {
            await loadDecks();
            renderDeckList();
            openDeckList();
        });

        document.getElementById('create-new-deck-btn').addEventListener('click', () => {
            closeDeckList();
            openDeckBuilder();
        });

        document.getElementById('closeDeckListBtn').addEventListener('click', closeDeckList);

        document.getElementById('closeDeckBuilderBtn').addEventListener('click', closeDeckBuilder);

        document.getElementById('saveDeckBtn').addEventListener('click', saveDeck);
        document.getElementById('deleteDeckBtn').addEventListener('click', deleteDeck);

        // Initialize drag and drop
        setupDragAndDrop();

        // ==================== END DECK SYSTEM ====================

        // Initialize
        const init = async () => {
            showLoading(true);

            // Initialize image cache manager
            try {
                await imageCacheManager.init();
                console.log('Image cache manager initialized');
            } catch (error) {
                console.error('Failed to initialize image cache manager:', error);
            }

            await loadCardData();

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // Check if user is VIP member
                    const vipData = localStorage.getItem('vip_membership');
                    let isVipMember = false;

                    if (vipData) {
                        try {
                            const parsed = JSON.parse(vipData);
                            if (parsed.active && parsed.verified) {
                                isVipMember = true;
                            }
                        } catch (e) {
                            console.error('Error parsing VIP data:', e);
                        }
                    }

                    // Redirect non-VIP users
                    if (!isVipMember) {
                        alert('このページはVIPメンバー専用です。\n\nカードリストページに戻ります。');
                        window.location.href = 'card_list.html';
                        return;
                    }

                    // User is VIP, proceed with loading
                    currentUser = user;
                    loadAllData(user.uid);

                    // Load saved grid size
                    const savedSize = localStorage.getItem('galleryGridSize');
                    if (savedSize) {
                        currentGridSize = savedSize;
                        document.querySelectorAll('.size-btn').forEach(btn => {
                            if (btn.dataset.size === savedSize) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        });
                    }

                    // Load saved list type
                    const savedListType = localStorage.getItem('galleryListType');
                    if (savedListType && (savedListType === 'collection' || savedListType === 'wishlist')) {
                        currentListType = savedListType;
                    }
                } else {
                    // Redirect to login page
                    alert('ログインが必要です。');
                    window.location.href = 'card_list.html';
                }
            });
        };

        init();
    </script>
</body>
</html>
